<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>

    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <link rel="stylesheet" href="css/bootstrap.css">
    <link rel="stylesheet" href="css/cluster.css">
    <link rel="stylesheet" href="css/jquery-ui.min.css">
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <script src="lib/jquery/jquery-1.8.3.min.js"></script>
    <script src="lib/d3.v3.js"></script>
    <script src="lib/tooltip.js"></script>
    <script src="lib/d3.min.js"></script>
    <script src="lib/angular/angular.js"></script>
    <script src="lib/underscore.js"></script>
    <!-- // <script src="js/directives/scatter-plot-matrix.js"></script> -->
    <script src="data/scatterdata.js"></script>
<style>

svg {
  font: 10px sans-serif;
  padding: 10px;
}

.axis,
.frame {
  shape-rendering: crispEdges;
}

.axis line {
  stroke: #ddd;
}

.axis path {
  display: none;
}

.frame {
  fill: none;
  stroke: #aaa;
}

circle {
  fill-opacity: .7;
}

circle.hidden {
  fill: #ccc !important;
}

.extent {
  fill: #000;
  fill-opacity: .125;
  stroke: #fff;
}

</style>
   
</head>
<body>    

<div id='scatterplotmatrixviz'>
</div>
<script type="text/javascript">

 function start(dataString) {
    // var jsonData = dataString;
    var jsonData = jQuery.parseJSON(dataString);
    var cleanedData = [];
                for (var i in jsonData.dataSeries) {
                    for (var j in jsonData.dataSeries[i]) {
                        if (!_.isNumber(jsonData.dataSeries[i][j]) && j !== "group") {
                            delete jsonData.dataSeries[i][j];
                        }
                    }
                    cleanedData.push(jsonData.dataSeries[i]);
                }

                var cleanedEquations = angular.copy(jsonData.equations);


                var size = 135,
                    padding = 15;

                var x = d3.scale.linear()
                    .range([padding , size - padding ]);

                var y = d3.scale.linear()
                    .range([size - padding , padding ]);

                var xAxis = d3.svg.axis()
                    .scale(x)
                    .orient("bottom")
                    .ticks(5);

                var yAxis = d3.svg.axis()
                    .scale(y)
                    .orient("left")
                    .ticks(5);

                var lineGenerator = d3.svg.line()
                    .x(function(d) {
                        return x(d.x);
                    })
                    .y(function(d) {
                        return y(d.y);
                    })
                    .interpolate("linear");

                var areaGenerator = d3.svg.area()
                    .x(function(d) {
                        return x(d.x);
                    })
                    .y0(function(d) {
                        return y(d.y0);
                    })
                    .y1(function(d) {
                        return y(d.y1);
                    });

                var brushCell;

                var color = d3.scale.category10();

                var domainByKey = {},
                    keys = d3.keys(cleanedData[0]).filter(function(d) {
                        return d !== "group";
                    }),
                    n = keys.length;

                keys.forEach(function(key) {
                    domainByKey[key] = d3.extent(cleanedData, function(d) {
                        return d[key];
                    });
                });

                xAxis.tickSize(size * n);
                yAxis.tickSize(-size * n);

                var brush = d3.svg.brush()
                    .x(x)
                    .y(y)
                    .on("brushstart", brushstart)
                    .on("brush", brushmove)
                    .on("brushend", brushend);

                var svg = d3.select("#scatterplotmatrixviz").append("svg")
                    .attr("width", size * n + padding * 2)
                    .attr("height", size * n + padding * 2)
                    .style("margin", "0 auto 0 auto")
                    .append("g")
                    .attr("transform", "translate(" + padding / 2 + "," + padding / 2 + ")");

                svg.selectAll(".x.axis")
                    .data(keys)
                    .enter().append("g")
                    .attr("class", "x axis")
                    .attr("transform", function(d, i) {
                        return "translate(" + (n - i - 1) * size + ",0)";
                    })
                    .each(function(d) {
                        x.domain(domainByKey[d]);
                        d3.select(this).call(xAxis);
                    });

                svg.selectAll(".y.axis")
                    .data(keys)
                    .enter().append("g")
                    .attr("class", "y axis")
                    .attr("transform", function(d, i) {
                        return "translate(0," + i * size + ")";
                    })
                    .each(function(d) {
                        y.domain(domainByKey[d]);
                        d3.select(this).call(yAxis);
                    });

                var cell = svg.selectAll(".cell")
                    .data(cross(keys, keys))
                    .enter().append("g")
                    .attr("class", "cell")
                    .attr("transform", function(d) {
                        return "translate(" + (n - d.i - 1) * size + "," + d.j * size + ")";
                    })
                    .each(plot);

                // Titles for the diagonal.
                cell.filter(function(d) {
                        return d.i === d.j;
                    })
                    .append("text")
                    .attr("width", size - padding)
                    .attr("height", size - padding)
                    .attr("x", padding / 2)
                    .attr("y", padding * 4)
                    .text(function(d){
                        return d.x;
                    });
                    // .html(function(d) {
                    //     return "<div style='width:" + (size - padding) + "px;height:" + (size - padding) + "px'><span>" + d.x + "</span></div>";
                    // });

                // Correlation display
                cell.filter(function(d) {
                        return d.i !== d.j;
                    })
                    .append("text")
                    .attr("width", size - padding)
                    .attr("height", size - padding)
                    .attr("x", padding * 2)
                    .attr("y", padding / 2)
                    .text(function(d){
                        for (prop in cleanedEquations) {
                            if (d.x + "-" + d.y === prop){
                                var cor = cleanedEquations[prop].correlation.toFixed(4);
                                return "Correlation: " + cor;
                            }
                        } 
                    });

                cell.filter(function(d) {
                    return d.i !== d.j;
                }).call(brush);

                function plot(p) {
                    var cell = d3.select(this);

                    x.domain(domainByKey[p.x]);
                    y.domain(domainByKey[p.y]);

                    cell.append("rect")
                        .attr("class", "frame")
                        .attr("x", padding / 2)
                        .attr("y", padding / 2)
                        .attr("width", size - padding)
                        .attr("height", size - padding);


                    if (p.x !== p.y) {
                        cell.selectAll("circle")
                            .data(cleanedData)
                            .enter().append("circle")
                            .attr("cx", function(d) {
                                return x(d[p.x]);
                            })
                            .attr("cy", function(d) {
                                return y(d[p.y]);
                            })
                            .attr("r", 3)
                            .style("fill", function(d) {
                                return color(d.group);
                            });

                        cell.append("path")
                            .attr("d", lineGenerator(getPoints(p)))
                            .attr("id", "regressionline")
                            .attr("stroke", "black")
                            .attr("stroke-width", "2px")
                            .style("opacity", .8);

                        cell.append("path")
                            .attr("d", areaGenerator(getPoints(p, "shade")))
                            .attr("id", "shader")
                            .attr("class", "shader")
                            .attr("opacity", .05);

                        cell.on("mouseover", function(d) {
                            cell.selectAll("circle")
                                .style("opacity", .15);

                            cell.selectAll("#shader")
                                .style("opacity", .5);

                            cell.selectAll("#regressionline")
                                .style("opacity", 1);
                        });

                       cell.on("mouseout", function(d) {
                            cell.selectAll("circle")
                                .style("opacity", 1);

                            cell.selectAll("#shader")
                                .style("opacity", .1);

                            cell.selectAll("#regressionline")
                                .style("opacity", .8);
                        });
                    }
                };

                // Clear the previously-active brush, if any.
                function brushstart(p) {
                    if (brushCell !== this) {
                        d3.select(brushCell).call(brush.clear());
                        x.domain(domainByKey[p.x]);
                        y.domain(domainByKey[p.y]);
                        brushCell = this;
                    }
                };

                // Highlight the selected circles.
                function brushmove(p) {
                    var e = brush.extent();
                    svg.selectAll("circle").classed("hidden", function(d) {
                        return e[0][0] > d[p.x] || d[p.x] > e[1][0] || e[0][1] > d[p.y] || d[p.y] > e[1][1];
                    });
                };

                // If the brush is empty, select all circles.
                function brushend() {
                    if (brush.empty()) svg.selectAll(".hidden").classed("hidden", false);
                };

                function cross(a, b) {
                    var c = [],
                        n = a.length,
                        m = b.length,
                        i, j;
                    for (i = -1; ++i < n;)
                        for (j = -1; ++j < m;) c.push({
                            x: a[i],
                           i: i,
                            y: b[j],
                            j: j
                        });
                    return c;
                };

                function getPoints(p, shade) {
                    var cleanedLinePoints = [];
                    x.domain(domainByKey[p.x]);
                    y.domain(domainByKey[p.y]);

                    //get coefficients
                    for (var i in cleanedEquations) {
                        if (cleanedEquations[i].x === p.x && cleanedEquations[i].y === p.y) {
                            var rawEquation = cleanedEquations[i].equation;
                            var lineEquation = rawEquation.split("\u003d").pop().replace(/\s+/g, '').split("x+");
                            var lineM = +lineEquation[0];
                            var lineB = +lineEquation[1];
                            var lineShift = +cleanedEquations[i].shift;
                            var minX = domainByKey[p.x][0]*.05;
                            var maxX = domainByKey[p.x][1]*1.05;
                            var minY = domainByKey[p.y][0]*.35;
                            var maxY = domainByKey[p.y][1]*1.05;


                            //generate points
                            for (var i = 0; i < 1001; i++) {
                                var point = {};
                                if (shade === "shade") {
                                    point['x'] = minX + (maxX - minX) * i / 1000;
                                    point['y0'] = lineM * (point['x']) + lineB - lineShift;
                                    point['y1'] = lineM * (point['x']) + lineB + lineShift;
                                    if ((minY <= point['y0'] && point['y0'] <= maxY) || (minY <= point['y1'] && point['y1'] <= maxY)) {
                                        if (point['y0'] <= maxY && maxY <= point['y1']) {
                                            point['y1'] = maxY;
                                        } else if (minY <= point['y1'] && point['y0'] <= minY) {
                                            point['y0'] = minY;
                                        }
                                        cleanedLinePoints.push(point);
                                    }
                                } else {
                                    point['x'] = minX + (maxX - minX) * i / 1000;
                                    point['y'] = lineM * (point['x']) + lineB;
                                    if (minY <= point['y'] && point['y'] <= maxY) {
                                        cleanedLinePoints.push(point);
                                    }
                                }
                            }
                            break;
                        }
                    }
                    return cleanedLinePoints
                };
                d3.select(self.frameElement).style("height", size * n + padding + 20 + "px");
            };
start();


</script>
</body>
</html>

    