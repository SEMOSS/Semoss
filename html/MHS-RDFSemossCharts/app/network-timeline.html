<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Network Timeline</title>
    <link rel="stylesheet" type="text/css" href="css/ng-table.css">
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <link rel="stylesheet" type="text/css" href="css/tooltip.css">
    <link rel="stylesheet" href="css/d3.slider.css" />
    <link rel="stylesheet" href="css/network-timeline.css" />
</head>
<body ng-app="main">
    <div id="controllerID" ng-controller="NetworkCtrl">
        <div id="sidebarHeader">
            <div class="slider-container">
                <div id="slider"></div>
            </div>
        </div>
        <div id="sidebarContainer">
            <div id="sidebarContentArea">

                <div id="sidebarContentLeft">
                    <table ng-table="tableParams" show-filter="true" class="table">
                        <tr ng-repeat="user in $data">
                            <td data-title="'Phase'" class="phase" sortable="'phase'" filter="{ 'phase': 'text' }" header-class = "text-center">
                                {{user.phase}}
                            </td>
                            <td data-title="'LOE'" class="loe" sortable="'loe'" filter="{ 'LOE': 'text' }" header-class = "text-center" class="text-right" >
                                {{user.LOE}}
                            </td>
                            <td data-title="'Dependent ICDs'" class="icd" sortable="'dependICDS'" filter="{ 'dependICDS': 'text' }" header-class = "text-center" class="text-right" >
                                {{user.dependICDS}}
                            </td>
                            <td data-title="'GL Item'" class="gl-item" sortable="'GLitem'" filter="{ 'GLitem': 'text' }" header-class = "text-center" class="text-right" >
                                {{user.GLitem}}
                            </td>
                            <td data-title="'GL Tag'" class="gl-tag" sortable="'gltag'" filter="{ 'gltag': 'text' }" header-class = "text-center" class="text-right" >
                                {{user.gltag}}
                            </td>
                        </tr>
                    </table>
                </div>

                <div id="sidebarContentRight">
                    <forcegraph data="forceData"></forcegraph>
                </div>

            </div>
            <div id="sidebarFooter"></div>
        </div>
    </div>
    <script src="lib/angular/angular_new.js"></script>
    <script src="js/ng-table.js"></script>

    <script type="text/javascript" src="lib/d3.v3.js"></script>
    <script type="text/javascript" src="lib/tooltip.js"></script>
    <script src="lib/jquery/jquery-1.11.0.min.js"></script>
    <script src="lib/jquery/jquery-ui.min.js"></script>
    <script src="lib/underscore.js"></script>
    <script src="lib/bootstrap-slider.js"></script>
    <script src="lib/d3.slider.js"></script>
    <script src="data/timeline-data.js"></script>
    <script>

        //$("#sidebarContentLeft").resizable({
        //        handles: 'e'
        //    });

        function start(dataPassed) {

            var ctrlScope = angular.element(jQuery('#controllerID')).scope();
            // calling function in controller
            ctrlScope.setJSONData(dataPassed);

        };

        angular.module('main', ['ngTable']).
            controller('NetworkCtrl', function($scope, $filter, ngTableParams, $timeout) {
                    $scope.forceData = '';
                    $scope.tableData = [];

                    $timeout(function () {
                        $scope.forceData = timeline_data;
                        //setTableData($scope.forceData.nodes);
	                    setTableData($scope.forceData.edges);
                    }, 500);

                    $scope.setJSONData = function (data) {
                        $scope.$apply(function () {
                            $scope.forceData = jQuery.parseJSON(data);
                            //setTableData($scope.forceData.nodes);
	                        setTableData($scope.forceData.edges);
                        });
                    };

                    function setTableData(array) {
                        var tableData = [];
                        for (var prop = 0; prop < array.length; prop++) {
                            if (array[prop].propHash.timeHash) {
	                            if(array[prop].propHash.timeHash["Decommissioned"]) { //decommissioned
		                            /*
		                            var newItem = {
			                            phase: "Decommissioned",
			                            LOE: 0,
			                            dependICDS: "",
			                            GLitem: "",
			                            gltag: ""
		                            };
		                            tableData.push(newItem);
		                            */
	                            } else { //requirements, design, test, develop, deploy phases
		                            for(var timeHashProp in array[prop].propHash.timeHash) {
			                            var newItem = {
				                            phase: array[prop].propHash.timeHash[timeHashProp].phase,
				                            LOE: array[prop].propHash.timeHash[timeHashProp].LOE,
				                            dependICDS: array[prop].propHash.timeHash[timeHashProp].dependICDS,
				                            GLitem: array[prop].propHash.timeHash[timeHashProp].GLitem,
				                            gltag: array[prop].propHash.timeHash[timeHashProp].gltag
			                            };
			                            tableData.push(newItem);
		                            }

	                            }
                            } else { //timeHash property doesn't exist

                            }
                        } //end of forloop

                        $scope.tableData = tableData;
                        $scope.tableParams.count(tableData.length);
                        $scope.tableParams.reload();
                    }

                    function getTableData() {
                        if ($scope.tableData) {
                            return $scope.tableData;
                        } else {
                            return [];
                        }
                    }

                    $scope.tableParams = new ngTableParams({
                        count: getTableData().length,          // count per page
                        sorting: {
                            phase: 'asc'     // initial sorting
                        }
                    }, {
                        total: getTableData().length, // length of data
                        getData: function($defer, params) {
                            var data = getTableData();
                            // use build-in angular filter
                            var filteredData = params.filter() ?
                                    $filter('filter')(data, params.filter()) :
                                    data;
                            var orderedData = params.sorting() ?
                                    $filter('orderBy')(filteredData, params.orderBy()) :
                                    data;
                            params.total(orderedData.length); // set total for recalc pagination
                            $defer.resolve(orderedData.slice((params.page() - 1) * params.count(), params.page() * params.count()));
                        }
                    });
            }).
            directive('forcegraph', function() {
                    return {
                        restrict: 'AE',
                        scope: {
                            data: '=',
                            d3Width: '=',
                            d3Height: '=',
                            toggleLabel: '=',
                            uriSend: '&uri',
                            clearGraph: '=',
                            control: '=',
                            sendLegend: '&',
                            containerClass: "=",
                            isMenuOpen: "=",
                            showTitle: "=",
                            labels: "="
                        },
                        link: function (scope, ele, attrs) {
                            var links = [],
                                    nodes = [],
                                    newNodes = [],
                                    newLinks = [],
                                    obj = {},
                                    linkedByIndex = {},
                                    legendNodes = [],
                                    margin = {top: 100, right: 100, bottom: 100, left: 100},
                                    container = {width: 0, height: 0},
                                    maxLOE = 0,
                                    minLOE = 0;

                            //TODO: this needs to be refactored to use container and margin objects
                            var width = 0;
                            var height = 0;
                            width = parseInt(d3.select('#sidebarContentRight').style('width'));
                            height = parseInt(d3.select('#sidebarContentRight').style('height'));

                            scope.$watch('data', function() {
                                if (!_.isEmpty(scope.data)) {

                                    newNodes = scope.data.nodes;
                                    newLinks = scope.data.edges;

                                    for (var prop in newNodes) {
                                        obj = $.extend({}, newNodes[prop]);
                                        obj.id = prop;
                                        nodes.push(obj);
                                    }
                                    newLinks.forEach(function (link) {
                                        //depending on if the link.source & link.target are already pointing to
                                        //strings or object instances
                                        link.source = findNode(link.source) || findNode(link.source.id);
                                        link.target = findNode(link.target) || findNode(link.target.id);
                                        links.push(link);
                                    });

                                    calculateMaxLOE();

                                    d3.select('#slider')
                                        .call(
		                                    d3.slider().axis(true).min(minLOE).max(maxLOE).step(2).value(0)
			                                    .on('slide', function (e, v) {
		                                            console.log(e);
		                                            console.log(v);
                                            }));
                                    update();
                                }

                            });

                            var xScale = d3.scale.linear()
                                    .domain([0, width])
                                    .range([0, width]);

                            var yScale = d3.scale.linear()
                                    .domain([0, height])
                                    .range([0, height]);

                            var rScale = d3.scale.linear()
                                    .rangeRound([8, 16])
                                    .nice();

                            var lScale = d3.scale.linear()
                                    .range([1.5, 4.5]);

                            /*** Configure zoom behaviour ***/
                            //        var zoomer = d3.behavior.zoom()
                            //                .scaleExtent([0.1,10])
                            //                .x(xScale)
                            //                .y(yScale)
                            //                .on("zoom", zoom);

                            var force = d3.layout.force()
                                    .size([width, height])
                                    .gravity(.09) //attraction to the center of the screen and within the screen layout
                                    .linkDistance(60)
                                    .charge(-200) //amount of node repulsion(negative) or attraction(positive)
                                    .on("tick", tick);

                            var drag = force.drag()
                                    .origin(function (d) {
                                        return d;
                                    }); //center of circle
//                .on("dragstart", dragstarted)
//                .on('drag.force', dragged)
//                .on("drag", dragged)
//                .on("dragend", dragended);

                            var svg = d3.select(ele[0]).append("svg")
                                    .attr("width", width)
                                    .attr("height", height);

                            var graph = svg.append("g")
                                    .attr("class", "graph");
//                .call(zoomer); //Attach zoom behaviour.

                            var rect = graph.append("rect")
                                    .attr("width", width)
                                    .attr("height", height)
                                    .style("fill", "none")
                                //make transparent (vs black if commented-out)
                                    .style("pointer-events", "all");
                            //respond to mouse, even when transparent

                            var vis = graph.append("g")
                                    .attr("class", "plotting-area");

                            // Per-type markers, as they don't inherit styles.
                            var defs = vis.append("defs").selectAll("marker")
                                    .data(["end"])
                                    .enter().append("marker")
                                    .attr("id", function (d) {
                                        return d;
                                    })
                                    .attr("viewBox", "0 -5 10 10")
                                    .attr("refX", 15)
                                    .attr("refY", -1.5)
                                    .attr("markerWidth", 6)
                                    .attr("markerHeight", 6)
                                    .attr("orient", "auto")
                                    .append("path")
                                    .attr("d", "M0,-5L10,0L0,5")
                                    .style("pointer-events", "none"); //no events need to be fired off of marker

                            //add legend
                            var legendBox = svg.append("g")
                                    .attr("class", "legend")
                                    .attr("height", 100)
                                    .attr("width", 100);

                            var container = svg.append("g");

                            var node = vis.selectAll(".node"),
                                    link = vis.selectAll(".link");

                            nodes = force.nodes();
                            links = force.links();

                            function update() {
                                /*** Configure zoom behaviour ***/
                                var zoomer = d3.behavior.zoom()
                                        .scaleExtent([0.1,10])
                                        .x(xScale)
                                        .y(yScale)
                                        .on("zoom", zoom);
                                //set up legendNodes array for legend
                                var flags = {};
                                legendNodes = nodes.filter(function(node) {
                                    if (flags[node.propHash.VERTEX_TYPE_PROPERTY]) {
                                        return false;
                                    }
                                    flags[node.propHash.VERTEX_TYPE_PROPERTY] = true;
                                    return true;
                                });

                                //highlight adjacent -> will be moved to a click event
                                links.forEach(function(d) {
                                    linkedByIndex[d.source.id + "," + d.target.id] = 1;
                                });

                                //link update...
                                link = link.data(links, function(d) {
                                    return d.source.id + "-" + d.target.id;
                                });

                                //link enter...
                                link.enter()
                                        .insert("path", ".node") //paths should always be placed before the group of nodes/text
                                        .attr("class", "link")
                                        .attr("marker-end", function(d) { return "url(#end)"; })
                                        .attr("id", function(d, i) { return "linkId_" + i; })
                                        .attr("fill", "none")
                                        .attr("stroke", "#666")
                                        .attr("stroke-width", 1.5);

                                //link exit...
                                link.exit()
                                        .transition().duration(500)
                                        .remove();

                                //node update...
                                node = node.data(nodes, function(d) {
                                    return d.id;
                                });

                                //node enter g...
                                var nodeEnter = node.enter().append("g")
                                        .attr("class", function(d) { return "node " + d.id; })
                                        .call(drag);

                                //node enter circle...
                                nodeEnter.append("circle")
                                        .attr("class", "node")
                                        .attr("r", 0).transition().duration(1000)
                                        .attr("r", 8)
                                        .attr("fill", function(d){
                                            return ("rgb(" + d.propHash.VERTEX_COLOR_PROPERTY + ")")
                                        })
                                        .attr("stroke", "#777")
                                        .attr("stroke-width", 1.5)
                                        .attr("data-legend", function(d) {
                                            return d.propHash.VERTEX_COLOR_PROPERTY;
                                        });

                                //node enter text...
                                nodeEnter.append("text")
                                        .attr("class", "nodetext")
                                        .attr("x", 12)
                                        .attr("dy", ".35em")
                                        .attr("stroke", "none")
                                        .style("font-size", "10px")
                                        .text(function(d) {
                                            return d.propHash.VERTEX_TYPE_PROPERTY;
                                        });

                                //node group removal with transition...
                                node.exit()
                                        .selectAll("circle")
                                        .transition().duration(1000)
                                        .attr("r", 0)
                                        .remove();
                                node.exit()
                                        .selectAll("text")
                                        .transition().duration(1000)
                                        .style("font-size","0px")
                                        .remove();
                                node.exit().transition().delay(1000).remove();

                                //legend update...
                                var legend = legendBox.selectAll('circle')
                                        .data(legendNodes, function(d) {
                                            return d.propHash.VERTEX_TYPE_PROPERTY;
                                        });

                                //legend enter...
                                legend.enter()
                                        .append("circle")
                                        .attr("r", 0)
                                        .transition().duration(1000)
                                        .attr("r", 6)
                                        .attr("stroke-width", 1)
                                        .attr("stroke", function(d) {
                                            return ("rgb(" + d.propHash.VERTEX_COLOR_PROPERTY + ")");
                                        })
                                        .attr("transform", function(d, i) { return "translate(20," + ((i * 20) + 15) + ")"; })
                                        .style("fill", function(d) {
                                            return ("rgb(" + d.propHash.VERTEX_COLOR_PROPERTY + ")");
                                        });

                                //legend exit...(move below with legendText exit?)
                                legend.exit().transition()
                                        .attr("r", 0)
                                        .remove();

                                //legendText update...
                                var legendText = legendBox.selectAll('text')
                                        .data(legendNodes, function(d) {
                                            return d.propHash.VERTEX_TYPE_PROPERTY;
                                        });

                                //legendText enter...
                                legendText.enter()
                                        .append("text")
                                        .transition().duration(1000)
                                        .attr("x", 12)
                                        .attr("transform", function(d, i) { return "translate(20," + ((i * 20) + 19) + ")"; })
                                        .text(function(d) {
                                            return d.propHash.VERTEX_TYPE_PROPERTY;
                                        });

                                //legendText exit...
                                legendText.exit().transition()
                                        .remove();

                                var legendTextArray = [];
                                //setting array of just the name values of each type, then sending them to a controller function
                                for (var i=0; i< legendNodes.length; i++) {
                                    legendTextArray.push(legendNodes[i].propHash.VERTEX_TYPE_PROPERTY);
                                }

                                //need to combine this selectALL and the bottom selectAll into one group
                                d3.select(".legend").selectAll("text")
                                        .style("cursor", "pointer")
                                        .on("click", function(d) {
                                            legendClick(d);
                                        });

                                d3.select(".legend").selectAll("circle")
                                        .style("cursor", "pointer")
                                        .on("click", function(d) {
                                            legendClick(d);
                                        });

                                force.start();
                            }

                            function calculateMaxLOE() {

	                            for (var i=0; i  < links.length; i++) {
                                    if (links[i].propHash.timeHash) {
                                        var total = 0;
                                        if (links[i].propHash.timeHash.Design) {
                                            total += links[i].propHash.timeHash.Design.LOE;
                                        }
                                        if (links[i].propHash.timeHash.Requirements) {
                                            total += links[i].propHash.timeHash.Requirements.LOE;
                                        }
                                        if (links[i].propHash.timeHash.Test) {
                                            total += links[i].propHash.timeHash.Test.LOE;
                                        }
                                        if (links[i].propHash.timeHash.Develop) {
                                            total += links[i].propHash.timeHash.Develop.LOE;
                                        }
                                    }

                                    if (total > maxLOE) {
                                        maxLOE = total;
                                    }
                                }

                            }

                            function updatePhase() {
                                d3.select('.node');
                            }

                            //find node by 'id' within nodes array
                            function findNode(id) {
                                for (var i in nodes) {
                                    if (nodes[i]["id"] === id)
                                        return nodes[i]
                                };
                            }

                            //Please comment
                            function zoom() {
                                tick();
                            }

                            //Please comment
                            function tick() {
                                link.attr("d", linkArc);
                                node.attr("transform", function(d) {
                                    return "translate(" + xScale(d.x) + "," + yScale(d.y) + ")"; });
                            }

                            //create curved paths between nodes
                            function linkArc(d) {
                                var dx = xScale(d.target.x) - xScale(d.source.x),
                                        dy = yScale(d.target.y) - yScale(d.source.y),
                                        dr = Math.sqrt(dx * dx + dy * dy);
                                return "M" + xScale(d.source.x) + "," + yScale(d.source.y) + "A" + dr + "," + dr + " 0 0,1 " + xScale(d.target.x) + "," + yScale(d.target.y);
                            }


                        }//end of link
                    }//end of return
            });



        //start(timeline_data);
    </script>
</body>
</html>