<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Network Timeline</title>
    <link rel="stylesheet" type="text/css" href="css/ng-table.css">
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <link rel="stylesheet" type="text/css" href="css/tooltip.css">
    <link rel="stylesheet" href="css/d3.slider.css" />
    <link rel="stylesheet" href="css/font-awesome.css" />
    <link rel="stylesheet" href="css/network-timeline.css" />
</head>
<body ng-app="main">
    <div id="controllerID" ng-controller="NetworkCtrl">
        <div id="sidebarHeader">
            <div class="header-left">
                <div class="header-title text-center">Update State</div>
                <div class="btn-group text-center">
                    <button type="button" class="btn" ng-click="setInitialStateSlider()">Initial State</button>
                    <button type="button" class="btn" ng-click="setFinalStateSlider()">Final State</button>
                </div>
            </div>

            <div class="slider-container">
                <div class="header-title text-center">Transition Modernization LOE Slider</div>
                <div id="slider"></div>
            </div>

        </div>
        <div id="sidebarContainer">
            <div id="sidebarContentArea">

                <div id="sidebarContentLeft">
                    <div class="sidebar-title header-title text-center">Interface Modernization Status</div>
                    <table ng-table="tableParams" show-filter="true" class="table fixed-layout">
                        <tr ng-repeat="item in $data track by $index">
                            <td data-title="'ICD'" class="icd" sortable="'name'" filter="{ 'name': 'text' }" header-class = "text-center">
                                {{item.name}}
                            </td>
                            <td title="{{item.phase}}" data-title="'Phase'" class="label" ng-class="((item.phase))" sortable="'phase'" filter="{ 'phase': 'text' }" header-class = "text-center phase">
                                {{item.phase}}
                            </td>
                            <td title="{{item.LOE}}" data-title="'LOE'" sortable="'loe'" filter="{ 'LOE': 'text' }" header-class = "text-center loe" class="text-right" >
                                {{item.LOE}}
                            </td>
                            <td title="{{item.gltag}}" data-title="'GL Tag'" sortable="'gltag'" filter="{ 'gltag': 'text' }" header-class = "text-center gl-tag" class="text-right" >
                                {{item.gltag}}
                            </td>
                        </tr>
                    </table>
                </div>

                <div id="sidebarContentRight">
                    <div class="sidebar-title">
                        <button class="sm-btn btn-light pull-right btn-margin-left" ng-click="unfreezeNodes()" title="Unlock Graph">
                            <i class="fa fa-unlock-alt"></i>
                        </button>

                        <button class="sm-btn btn-light pull-right btn-margin-left" ng-click="freezeNodes()" title="Lock Graph">
                            <i class="fa fa-lock"></i>
                        </button>

                         <div class="header-title text-center">
                            Network Transition Visualization
                        </div>
                    </div>
                    <forcegraph data="forceData" max-loe="maxLOE" time-hash="timeHashLocation"></forcegraph>
                </div>

            </div>
            <div id="sidebarFooter"></div>
        </div>
    </div>
    <script src="lib/angular/angular_new.js"></script>
    <script src="js/ng-table.js"></script>

    <script type="text/javascript" src="lib/d3.v3.js"></script>
    <script type="text/javascript" src="lib/tooltip.js"></script>
    <script src="lib/jquery/jquery-1.11.0.min.js"></script>
    <script src="lib/jquery/jquery-ui.min.js"></script>
    <script src="lib/underscore.js"></script>
    <script src="lib/bootstrap-slider.js"></script>
    <script src="lib/d3.slider.js"></script>
    <script src="lib/taffy-min.js"></script>
    <!--<script src="data/timeline-data2.js"></script>-->

    <script>

        function start(dataPassed) {

            var ctrlScope = angular.element(jQuery('#controllerID')).scope();
            // calling function in controller
            ctrlScope.setJSONData(dataPassed);

        };

        angular.module('main', ['ngTable']).
            controller('NetworkCtrl', function($scope, $filter, ngTableParams, $timeout, $rootScope) {
                    $scope.forceData = '';
                    $scope.tableData = [];
                    var tableDB;
                    $scope.maxLOE = 0;
                    $scope.timeHashLocation = '';

//                    $timeout(function () {
//                        $scope.forceData = timeline_data;
//
//                        var tableData = [];
//
//                        //check if it nodes and/or edges have timeHash
//                        var nodesTimeHash = hasTimeHash($scope.forceData.nodes);
//                        var edgesTimeHash = hasTimeHash($scope.forceData.edges);
//
//                        if (nodesTimeHash && edgesTimeHash) {
//                            $scope.timeHashLocation = "Both";
//                            tableData = createTableModel($scope.forceData.nodes, "Nodes");
//                            var edgeTableData = createTableModel($scope.forceData.edges, "Edges");
//                            //combine tables
//                            for (var i=0; i<edgeTableData.length; i++) {
//                                tableData.push(edgeTableData[i]);
//                            }
//                        } else if (nodesTimeHash) {
//                            $scope.timeHashLocation = "Nodes";
//                            tableData = createTableModel($scope.forceData.nodes, "Nodes");
//                        } else if (edgesTimeHash) {
//                            $scope.timeHashLocation = "Edges";
//                            tableData = createTableModel($scope.forceData.edges, "Edges");
//                        }
//
//                        tableDB = TAFFY(tableData);
//                        setTableData(0);
//
//                    }, 500);

                    $scope.setJSONData = function (data) {
                        $scope.$apply(function () {

                            $scope.forceData = JSON.parse(data);
                            var tableData = [];

                            //check if it nodes and/or edges have timeHash
                            var nodesTimeHash = hasTimeHash($scope.forceData.nodes);
                            var edgesTimeHash = hasTimeHash($scope.forceData.edges);

                            if (nodesTimeHash && edgesTimeHash) {
                                $scope.timeHashLocation = "Both";
                                tableData = createTableModel($scope.forceData.nodes, "Nodes");
                                var edgeTableData = createTableModel($scope.forceData.edges, "Edges");
                                //combine tables
                                for (var i=0; i<edgeTableData.length; i++) {
                                    tableData.push(edgeTableData[i]);
                                }
                            } else if (nodesTimeHash) {
                                $scope.timeHashLocation = "Nodes";
                                tableData = createTableModel($scope.forceData.nodes, "Nodes");
                            } else if (edgesTimeHash) {
                                $scope.timeHashLocation = "Edges";
                                tableData = createTableModel($scope.forceData.edges, "Edges");
                            }

                            tableDB = TAFFY(tableData);
                            setTableData(0);

                        });
                    };

                    function hasTimeHash(collection) {
                        for (var item in collection) {
                            if (collection[item].propHash.timeHash) {
                                return true;
                            }
                        }
                        return false;
                    }

                    function createTableModel(itemArray, timeHashLocation) {
                        var tableData = [];

                        if (timeHashLocation == "Nodes") {
                            var name = "VERTEX_LABEL_PROPERTY";
                            var type = "VERTEX_TYPE_PROPERTY";
                        } else if (timeHashLocation == "Edges") {
                            var name = "EDGE_NAME";
                            var type = "EDGE_TYPE";
                        }

                        for (var item in itemArray) {

                            if (itemArray[item].propHash.timeHash) {
                                if (itemArray[item].propHash.timeHash["Decommissioned"]) { //decommissioned
                                    //new item data model
                                    newItem = {
                                        name: itemArray[item].propHash[name],
                                        uri: itemArray[item].uri,
                                        phase: "Decommissioned",
                                        startLOE: 0,
                                        LOE: 0,
                                        totalLOE: 0,
                                        dependICDS: [],
                                        gltag: "",
                                        type: itemArray[item].propHash[type]
                                    };

                                    tableData.push(newItem);
                                } else { //requirements, design, test, develop, deploy phases

                                    //create total for LOE hours
                                    var totalLOE = 0;
                                    var phases = ["Requirements", "Design", "Develop", "Test", "Deploy"];

                                    for (var i = 0; i < phases.length; i++) {
                                        if (itemArray[item].propHash.timeHash[phases[i]]) {

                                            //parse the dependent icds list
                                            itemArray[item].propHash.timeHash[phases[i]].dependICDS = jQuery.parseJSON(itemArray[item].propHash.timeHash[phases[i]].dependICDS);

                                            //new item data model
                                            var newItem = {};
                                            newItem.name = itemArray[item].propHash[name];
                                            newItem.uri = itemArray[item].uri;
                                            newItem.phase = itemArray[item].propHash.timeHash[phases[i]].phase;
                                            newItem.startLOE = totalLOE;
                                            newItem.LOE = itemArray[item].propHash.timeHash[phases[i]].LOE;
                                            //set the edges properties
                                            itemArray[item].propHash.timeHash[phases[i]].startLOE = totalLOE;

                                            //add to previous total
                                            totalLOE += itemArray[item].propHash.timeHash[phases[i]].LOE;

                                            //set the edges properties
                                            itemArray[item].propHash.timeHash[phases[i]].totalLOE = totalLOE;
                                            newItem.totalLOE = totalLOE;
                                            newItem.dependICDS = itemArray[item].propHash.timeHash[phases[i]].dependICDS;
                                            newItem.gltag = itemArray[item].propHash.timeHash[phases[i]].gltag;
                                            newItem.type = itemArray[item].propHash[type];

                                            tableData.push(newItem);
                                        }
                                    }

                                    //add the completed state
                                    var newItem = {
                                        name: itemArray[item].propHash[name],
                                        uri: itemArray[item].uri,
                                        phase: "Completed",
                                        startLOE: totalLOE,
                                        LOE: 0,
                                        totalLOE: totalLOE,
                                        dependICDS: itemArray[item].propHash.timeHash["Requirements"].dependICDS,
                                        gltag: "",
                                        type: itemArray[item].propHash[type]
                                    };
                                    itemArray[item].propHash.timeHash["Completed"] = newItem;

                                    tableData.push(newItem);
                                }
                            } else {
                                //new item data modelcreateedge
                                var newItem = {
                                    name: itemArray[item].propHash[name],
                                    uri: itemArray[item].uri,
                                    phase: "N/A",
                                    startLOE: 0,
                                    LOE: 0,
                                    totalLOE: 0,
                                    dependICDS: [],
                                    gltag: "",
                                    type: itemArray[item].propHash[type]
                                };
                                tableData.push(newItem);
                            }

                        }

                        return tableData;

                    };

                    function setTableData(sliderValue) {
                        var dependICDs = [];

                        //get all dependent ICDs that can be decommissioned
                        tableDB().each(function(item) {
                            if (item.totalLOE < sliderValue && item.phase == "Completed") {
                                for (var i=0; i<item.dependICDS.length; i++) {
                                    dependICDs.push(item.dependICDS[i]);
                                }

                            }
                        });

                        $scope.tableData = tableDB(function() {
                            //checks first to see if the dependent ICD is able to be decommissioned
                            for (var i = 0; i < dependICDs.length; i++) {
                                if (dependICDs[i] == this.uri) {
                                    return true;
                                }
                            }


                            //show all the ICDs at t=0
                            if (sliderValue == 0 && this.phase != "Decommissioned" && this.totalLOE == 0) {
                                return true;
                            } else if (sliderValue !== 0) {

                                //completed phase only has a start and no end, so only check the startLOE and phase name
                                if (sliderValue > this.startLOE && this.phase == "Completed") {
                                    return true;
                                }
                                //all other phases are based on the start and total LOE
                                else if (this.totalLOE >= sliderValue && sliderValue > this.startLOE) {
                                    return true;
                                }
                                //add the decommissioned systems if the slider is over the maxLOE
                                else if (sliderValue >= $scope.maxLOE && this.phase == "Decommissioned") {
                                    return true;
                                }
                                //all else don't include
                                else {
                                    return false;
                                }
                            }
                        }).get();

                        $scope.tableParams.count($scope.tableData.length);
                        $scope.tableParams.reload();
                    }

                    $rootScope.$on('update-table', function(event, sliderVal) {
                        setTableData(sliderVal);
                    });

                    function getTableData() {
                        if ($scope.tableData) {
                            return $scope.tableData;
                        } else {
                            return [];
                        }
                    }

                    $scope.tableParams = new ngTableParams({
                        count: getTableData().length,          // count per page
                        sorting: {
                            phase: 'asc'     // initial sorting
                        }
                    }, {
                        counts: [],
                        total: getTableData().length, // length of data
                        getData: function($defer, params) {
                            var data = getTableData();
                            // use build-in angular filter
                            var filteredData = params.filter() ?
                                    $filter('filter')(data, params.filter()) :
                                    data;
                            var orderedData = params.sorting() ?
                                    $filter('orderBy')(filteredData, params.orderBy()) :
                                    data;
                            params.total(orderedData.length); // set total for recalc pagination
                            $defer.resolve(orderedData.slice((params.page() - 1) * params.count(), params.page() * params.count()));
                        }
                    });


                    $scope.setInitialStateSlider = function() {
                        $scope.$broadcast("set-slider-initial", 0);
                    };

                    $scope.setFinalStateSlider = function() {
                        if ($scope.maxLOE == 1) {
                            $scope.$broadcast("set-slider-final", 1);
                        } else {
                            $scope.$broadcast("set-slider-final", $scope.maxLOE + 1);
                        }
                    };

                    $scope.freezeNodes = function() {
                        $scope.$broadcast("freeze-nodes");
                    };

                    $scope.unfreezeNodes = function() {
                        $scope.$broadcast("unfreeze-nodes");
                    };

            }).
            directive('forcegraph', function($rootScope) {
                    return {
                        restrict: 'AE',
                        scope: {
                            data: '=',
                            containerClass: "=",
                            labels: "=",
                            maxLoe: "=",
                            timeHash: "="
                        },
                        link: function (scope, ele, attrs) {
                            var links = [],
                                    nodes = [],
                                    newNodes = [],
                                    newLinks = [],
                                    obj = {},
                                    linkedByIndex = {},
                                    legendNodes = [],
                                    margin = {top: 100, right: 100, bottom: 100, left: 100},
                                    container = {width: 0, height: 0},
                                    minLOE = 0,
                                    allForceData,
                                    previousSliderValue,
                                    isSliderMade = false,
                                    previousState = "Initial";

                            //TODO: this needs to be refactored to use container and margin objects
                            var width = 0;
                            var height = 0;
                            width = parseInt(d3.select('#sidebarContentRight').style('width'));
                            height = parseInt(d3.select('#sidebarContentRight').style('height'));

                            scope.$watch('data', function() {
                                if (!_.isEmpty(scope.data)) {
                                    //save all the data for later
                                    allForceData = scope.data;
                                    setForceData(scope.data, 0);
                                }
                            });

                            function setForceData(newData, sliderValue) {
//                                newNodes = newData.nodes;

                                if (sliderValue == 0 && previousState == "Initial") {
                                    //initial Edges is dependent on initial nodes, must go after
                                    newNodes = getInitialNodes();
                                    newLinks = removeEdgesFromRemovedNodes(getInitialEdges(), _.difference(_.keys(allForceData.nodes), _.keys(getInitialNodes())));
                                } else {
                                    newLinks = newData.edges;
                                    newNodes = {};
                                    for (var i=0; i<newData.nodes.length; i++) {
                                        newNodes[newData.nodes[i]] = allForceData.nodes[newData.nodes[i]];
                                    }
                                }

                                for (var prop in newNodes) {
                                    obj = $.extend({}, newNodes[prop]);
                                    obj.id = prop;
                                    nodes.push(obj);
                                }
                                newLinks.forEach(function (link) {
                                    //depending on if the link.source & link.target are already pointing to
                                    //strings or object instances
                                    link.source = findNode(link.source) || findNode(link.source.id);
                                    link.target = findNode(link.target) || findNode(link.target.id);
                                    links.push(link);
                                });

                                if (!isSliderMade) {
                                    scope.maxLoe = calculateMaxLOE();
                                    createSlider();
                                    isSliderMade = true;
                                }

                                update();
                            }


                            function createSlider(val) {
                                //remove old slider
                                d3.select("#slider")
                                        .select("a").remove();

                                d3.select("#slider")
                                        .select("svg").remove();

                                //set up new slider
                                var sliderMax = 0;
                                var axisState = true;
                                if (scope.maxLoe == 0 || scope.maxLoe == 1) {
                                    scope.maxLoe = 1;
                                    sliderMax = 1;
                                    axisState = d3.svg.axis().ticks(1);
                                } else {
                                    sliderMax = scope.maxLoe + 5;
                                }

                                //set the slider
                                var sliderVal = val ? val : 0;

                                d3.select("#slider").call(d3.slider().axis(axisState).min(minLOE).max(sliderMax).step(1).value(sliderVal)
                                        .on('slide', function (e, v) {
                                            scope.$emit('slider-change', v);
                                        }));
                            }

                            scope.$on("set-slider-initial", function(e, v) {

                                createSlider(v);
                                if (previousState == "Final") {
                                    var diffNodes = _.difference(_.keys(allForceData.nodes), _.keys(getFinalNodes()));
                                    var diffLinks = _.difference(allForceData.edges, removeEdgesFromRemovedNodes(getFinalEdges(), _.difference(_.keys(allForceData.nodes), _.keys(getFinalNodes()))));

                                    setForceData({nodes: diffNodes, edges: diffLinks}, v);


                                    diffNodes = _.difference(_.keys(allForceData.nodes), _.keys(getInitialNodes()));
                                    diffLinks = _.difference(allForceData.edges, removeEdgesFromRemovedNodes(getInitialEdges(), _.difference(_.keys(allForceData.nodes), _.keys(getInitialNodes()))));

                                    removeNodes(diffNodes);
                                    removeEdges(diffLinks);
                                    update();

                                } else if (previousState == "Transition") {
                                    var diffNodes = _.difference(_.keys(allForceData.nodes), _.keys(getInitialNodes()));
                                    var diffLinks = _.difference(allForceData.edges, removeEdgesFromRemovedNodes(getInitialEdges(), _.difference(_.keys(allForceData.nodes), _.keys(getInitialNodes()))));

                                    removeNodes(diffNodes);
                                    removeEdges(diffLinks);
                                    update();
                                }

                                previousState = "Initial";

                                scope.$emit("update-table", v);

                            });

                            scope.$on("set-slider-final", function(e, v) {

                                createSlider(v);
                                if (previousState == "Initial") {
                                    var diffNodes = _.difference(_.keys(allForceData.nodes), _.keys(getInitialNodes()));
                                    var diffLinks = _.difference(allForceData.edges, removeEdgesFromRemovedNodes(getInitialEdges(), _.difference(_.keys(allForceData.nodes), _.keys(getInitialNodes()))));
                                    setForceData({nodes: diffNodes, edges: diffLinks}, v);


                                    diffNodes = _.difference(_.keys(allForceData.nodes), _.keys(getFinalNodes()));
                                    diffLinks = _.difference(allForceData.edges, removeEdgesFromRemovedNodes(getFinalEdges(), _.difference(_.keys(allForceData.nodes), _.keys(getFinalNodes()))));

                                    removeNodes(diffNodes);
                                    removeEdges(diffLinks);
                                    update();

                                } else if (previousState == "Transition") {
                                    var diffNodes = _.difference(_.keys(allForceData.nodes), _.keys(getFinalNodes()));
                                    var diffLinks = _.difference(allForceData.edges, removeEdgesFromRemovedNodes(getFinalEdges(), _.difference(_.keys(allForceData.nodes), _.keys(getFinalNodes()))));

                                    removeNodes(diffNodes);
                                    removeEdges(diffLinks);
                                    update();
                                }

                                previousState = "Final";
                                scope.$emit("update-table", v);

                            });

                            $rootScope.$on('slider-change', function(event, sliderVal) {

                                if (previousState == "Initial") {
                                    var diffNodes = _.difference(_.keys(allForceData.nodes), _.keys(getInitialNodes()));
                                    var diffLinks = _.difference(allForceData.edges, removeEdgesFromRemovedNodes(getInitialEdges(), _.difference(_.keys(allForceData.nodes), _.keys(getInitialNodes()))));

                                    setForceData({nodes: diffNodes, edges: diffLinks}, sliderVal);
                                    updateEdgeColor(sliderVal);
                                    updateNodeColor(sliderVal);

                                } else if (previousState == "Final") {
                                    var diffNodes = _.difference(_.keys(allForceData.nodes), _.keys(getFinalNodes()));
                                    var diffLinks = _.difference(allForceData.edges, removeEdgesFromRemovedNodes(getFinalEdges(), _.difference(_.keys(allForceData.nodes), _.keys(getFinalNodes()))));

                                    setForceData({nodes: diffNodes, edges: diffLinks}, sliderVal);
                                    updateEdgeColor(sliderVal);
                                    updateNodeColor(sliderVal);

                                } else {
                                    updateEdgeColor(sliderVal);
                                    updateNodeColor(sliderVal);
                                }


                                scope.$emit('update-table', sliderVal);
                                previousState = "Transition";
                                previousSliderValue = sliderVal;

                            });

                            var xScale = d3.scale.linear()
                                    .domain([0, width])
                                    .range([0, width]);

                            var yScale = d3.scale.linear()
                                    .domain([0, height])
                                    .range([0, height]);

                            var rScale = d3.scale.linear()
                                    .rangeRound([8, 16])
                                    .nice();

                            var lScale = d3.scale.linear()
                                    .range([1.5, 4.5]);

                            /*** Configure zoom behaviour ***/
                            var zoomer = d3.behavior.zoom()
                                    .scaleExtent([0.1,10])
                                    .x(xScale)
                                    .y(yScale)
                                    .on("zoom", zoom);

                            var force = d3.layout.force()
                                    .size([width, height])
                                    .gravity(.09) //attraction to the center of the screen and within the screen layout
                                    .linkDistance(60)
                                    .charge(-200) //amount of node repulsion(negative) or attraction(positive)
                                    .on("tick", tick);

                            var drag = force.drag()
                                    .origin(function (d) {
                                        return d;
                                    }); //center of circle

                            var svg = d3.select(ele[0]).append("svg")
                                    .attr("width", width)
                                    .attr("height", height);

                            var graph = svg.append("g")
                                    .attr("class", "graph")
                                    .call(zoomer); //Attach zoom behaviour.

                            var rect = graph.append("rect")
                                    .attr("width", width)
                                    .attr("height", height)
                                    .style("fill", "none")
                                //make transparent (vs black if commented-out)
                                    .style("pointer-events", "all");
                            //respond to mouse, even when transparent

                            var vis = graph.append("g")
                                    .attr("class", "plotting-area");

                            // Per-type markers, as they don't inherit styles.
                            var defs = vis.append("defs").selectAll("marker")
                                    .data(["end"])
                                    .enter().append("marker")
                                    .attr("id", function (d) {
                                        return d;
                                    })
                                    .attr("viewBox", "0 -5 10 10")
                                    .attr("refX", 15)
                                    .attr("refY", -1.5)
                                    .attr("markerWidth", 6)
                                    .attr("markerHeight", 6)
                                    .attr("orient", "auto")
                                    .append("path")
                                    .attr("d", "M0,-5L10,0L0,5")
                                    .style("pointer-events", "none"); //no events need to be fired off of marker

                            //add legend
                            var legendBox = svg.append("g")
                                    .attr("class", "legend")
                                    .attr("height", 100)
                                    .attr("width", 100);

                            var container = svg.append("g");

                            var node = vis.selectAll(".node"),
                                    link = vis.selectAll(".link");

                            nodes = force.nodes();
                            links = force.links();

                            d3.select(window).on("resize", resize);

                            function update() {
                                /*** Configure zoom behaviour ***/
                                var zoomer = d3.behavior.zoom()
                                        .scaleExtent([0.1,10])
                                        .x(xScale)
                                        .y(yScale)
                                        .on("zoom", zoom);
                                //set up legendNodes array for legend
                                var flags = {};
                                legendNodes = nodes.filter(function(node) {
                                    if (flags[node.propHash.VERTEX_TYPE_PROPERTY]) {
                                        return false;
                                    }
                                    flags[node.propHash.VERTEX_TYPE_PROPERTY] = true;
                                    return true;
                                });

                                //highlight adjacent -> will be moved to a click event
                                links.forEach(function(d) {
                                    linkedByIndex[d.source.id + "," + d.target.id] = 1;
                                });

                                //link update...
                                link = link.data(links, function(d) {
                                    return d.source.id + "-" + d.target.id;
                                });

                                //link enter...
                                link.enter()
                                        .insert("path", ".node") //paths should always be placed before the group of nodes/text
                                        .attr("class", "link")
                                        .attr("marker-end", function(d) { return "url(#end)"; })
                                        .attr("id", function(d, i) { return "linkId_" + i; })
                                        .attr("fill", "none");

                                link.attr("stroke", "#666")
                                        .attr("stroke-width", 1.5);

                                //link exit...
                                link.exit()
                                        .transition().duration(500)
                                        .remove();

                                //node update...
                                node = node.data(nodes, function(d) {
                                    return d.id;
                                });

                                //node enter g...
                                var nodeEnter = node.enter().append("g")
                                        .attr("class", function(d) {
                                            var label = d.propHash.VERTEX_LABEL_PROPERTY.replace(/"/g, "").replace(/'/g, "").replace(/\(|\)/g, "");
                                            return "node " + label + " " + d.id;
                                        })
                                        .call(drag);

                                //node enter circle...
                                nodeEnter.append("circle")
                                        .attr("class", "node")
                                        .attr("r", 0).transition().duration(1000)
                                        .attr("r", 8)
                                        .attr("stroke", "#777")
                                        .attr("stroke-width", 1.5)
                                        .attr("data-legend", function(d) {
                                            return d.propHash.VERTEX_COLOR_PROPERTY;
                                        });

                                //node enter text...
                                nodeEnter.append("text")
                                        .attr("class", "nodetext")
                                        .attr("x", 12)
                                        .attr("dy", ".35em")
                                        .attr("stroke", "none")
                                        .style("font-size", "10px")
                                        .text(function(d) {
                                            return d.propHash.VERTEX_LABEL_PROPERTY;
                                        });

                                node.selectAll("circle")
                                        .attr("fill", function(d){
                                            return ("rgb(" + d.propHash.VERTEX_COLOR_PROPERTY + ")");
                                        });

                                //node group removal with transition...
                                node.exit()
                                        .selectAll("circle")
                                        .transition().duration(1000)
                                        .attr("r", 0)
                                        .remove();
                                node.exit()
                                        .selectAll("text")
                                        .transition().duration(1000)
                                        .style("font-size","0px")
                                        .remove();
                                node.exit().transition().delay(1000).remove();

                                //legend update...
                                var legend = legendBox.selectAll('circle')
                                        .data(legendNodes, function(d) {
                                            return d.propHash.VERTEX_TYPE_PROPERTY;
                                        });

                                //legend enter...
                                legend.enter()
                                        .append("circle")
                                        .attr("r", 0)
                                        .transition().duration(1000)
                                        .attr("r", 6)
                                        .attr("stroke-width", 1)
                                        .attr("stroke", function(d) {
                                            return ("rgb(" + d.propHash.VERTEX_COLOR_PROPERTY + ")");
                                        })
                                        .attr("transform", function(d, i) { return "translate(20," + ((i * 20) + 15) + ")"; })
                                        .style("fill", function(d) {
                                            return ("rgb(" + d.propHash.VERTEX_COLOR_PROPERTY + ")");
                                        });

                                //legend exit...(move below with legendText exit?)
                                legend.exit().transition()
                                        .attr("r", 0)
                                        .remove();

                                //legendText update...
                                var legendText = legendBox.selectAll('text')
                                        .data(legendNodes, function(d) {
                                            return d.propHash.VERTEX_TYPE_PROPERTY;
                                        });

                                //legendText enter...
                                legendText.enter()
                                        .append("text")
                                        .transition().duration(1000)
                                        .attr("x", 12)
                                        .attr("transform", function(d, i) { return "translate(20," + ((i * 20) + 19) + ")"; })
                                        .text(function(d) {
                                            return d.propHash.VERTEX_TYPE_PROPERTY;
                                        });

                                //legendText exit...
                                legendText.exit().transition()
                                        .remove();

                                var legendTextArray = [];
                                //setting array of just the name values of each type, then sending them to a controller function
                                for (var i=0; i< legendNodes.length; i++) {
                                    legendTextArray.push(legendNodes[i].propHash.VERTEX_TYPE_PROPERTY);
                                }

                                //need to combine this selectALL and the bottom selectAll into one group
                                d3.select(".legend").selectAll("text")
                                        .style("cursor", "pointer")
                                        .on("click", function(d) {
                                            legendClick(d);
                                        });

                                d3.select(".legend").selectAll("circle")
                                        .style("cursor", "pointer")
                                        .on("click", function(d) {
                                            legendClick(d);
                                        });

                                force.start();
                            }

                            //removes the edges that are connected to nodes that have been removed
                            function removeEdgesFromRemovedNodes(edges, removedNodes) {
                                var returnEdges = [];

                                //loops through edges, if the edge is linked to the removed node (boolean) then it does not get returned
                                for (var i=0; i<edges.length; i++) {
                                    for (var j=0; j<removedNodes.length; j++) {
                                        var linkedToRemovedNode = false;
                                        if ((edges[i].source == removedNodes[j] || edges[i].source.id == removedNodes[j]) || (edges[i].target == removedNodes[j] ||  edges[i].target.id == removedNodes[j])) {
                                            linkedToRemovedNode = true;
                                            break;
                                        }
                                    }

                                    if (!linkedToRemovedNode) {
                                        returnEdges.push(edges[i]);
                                    }
                                }

                                return returnEdges;
                            }

                            function getInitialEdges() {
                                var edges = [];
                                for (var i=0; i<allForceData.edges.length; i++) {
                                    if (!allForceData.edges[i].propHash.timeHash || (allForceData.edges[i].propHash.timeHash && allForceData.edges[i].propHash.timeHash["Decommissioned"])) {
                                        edges.push(allForceData.edges[i]);
                                    }
                                }

                                return edges;
                            }

                            function getFinalEdges() {
                                var edges = [];
                                for (var i=0; i<allForceData.edges.length; i++) {
                                    if (!allForceData.edges[i].propHash.timeHash || (allForceData.edges[i].propHash.timeHash && !allForceData.edges[i].propHash.timeHash["Decommissioned"])) {
                                        edges.push(allForceData.edges[i]);
                                    }
                                }

                                return edges;
                            }

                            function getInitialNodes() {
                                var returnNodes = {};

                                //goes through all nodes and only return ones that don't have a timeHash or have a timeHash with Decommissioned
                                for (var node in allForceData.nodes) {
                                    if (!allForceData.nodes[node].propHash.timeHash || (allForceData.nodes[node].propHash.timeHash && allForceData.nodes[node].propHash.timeHash["Decommissioned"])) {
                                        returnNodes[node] = allForceData.nodes[node];
                                    }
                                }


//                                //check all nodes to make sure that the edges of those nodes don't all have timeHash properties
                                for (var node in returnNodes) {

                                    //set the boolean to true so we are making the assumption there is only nonTimeHash
                                    var bool = false;
                                    for (var j=0; j< returnNodes[node].inEdge.length; j++) {
                                        if (scope.timeHash == "Nodes") {
                                            //check the nodes for timeHash
                                            var connectedNode = findNodeinAllNodes(returnNodes[node].inEdge[j].source);
                                            bool = checkForNonTimeHash(connectedNode);
                                            if (bool) {
                                                break;
                                            }
                                        }

                                        if (scope.timeHash == "Edges" || scope.timeHash == "Both") {
                                            //check edges themselves for timeHash
                                            bool = checkForNonTimeHash(returnNodes[node].inEdge[j]);
                                            if (bool) {
                                                break;
                                            }
                                        }

                                    }

                                    if (!bool) {
                                        for (var j=0; j< returnNodes[node].outEdge.length; j++) {

                                            if (scope.timeHash == "Nodes") {
                                                //check nodes
                                                var connectedNode = findNodeinAllNodes(returnNodes[node].outEdge[j].target);
                                                bool = checkForNonTimeHash(connectedNode);
                                                if (bool) {
                                                    break;
                                                }
                                            }

                                            if (scope.timeHash == "Edges" || scope.timeHash == "Both") {
                                                //check edges themselves for timeHash
                                                bool = checkForNonTimeHash(returnNodes[node].outEdge[j]);
                                                if (bool) {
                                                    break;
                                                }
                                            }

                                        }
                                    }

                                    if (!bool) {
                                        delete returnNodes[node];
                                    }

                                }

                                return returnNodes;
                            }

                            function checkForNonTimeHash(item) {
                                var bool = false;
                                if (!item.propHash.timeHash || (item.propHash.timeHash && item.propHash.timeHash["Decommissioned"])) {
                                    bool = true;
                                }
                                return bool;
                            }

                            function findNodeinAllNodes(id) {
                                for (var i in allForceData.nodes) {
                                    if (allForceData.nodes[i]["uri"] === id)
                                        return allForceData.nodes[i];
                                };
                            }

                            function getFinalNodes() {
                                var returnNodes = {};

                                if (scope.timeHash == "Nodes") {
                                    for (var node in allForceData.nodes) {
                                        if (!allForceData.nodes[node].propHash.timeHash || (allForceData.nodes[node].propHash.timeHash && !allForceData.nodes[node].propHash.timeHash["Decommissioned"])) {
                                            returnNodes[node] = allForceData.nodes[node];
                                        }
                                    }

                                    for (var node in returnNodes) {

                                        var hasNormalConnection = false;
                                        for (var i=0; i<returnNodes[node].inEdge.length; i++) {

                                            var connectedNode = findNodeinAllNodes(returnNodes[node].inEdge[i].source);
                                            if (connectedNode.propHash.timeHash && connectedNode.propHash.timeHash["Decommissioned"]) {
                                                continue;
                                            }

                                            else {
                                                hasNormalConnection = true;
                                                break;
                                            }

                                        }


                                        if (!hasNormalConnection) {
                                            for (var i=0; i<returnNodes[node].outEdge.length; i++) {

                                                var connectedNode = findNodeinAllNodes(returnNodes[node].outEdge[i].target);
                                                if (connectedNode.propHash.timeHash && connectedNode.propHash.timeHash["Decommissioned"]) {
                                                    continue;
                                                }

                                                else {
                                                    hasNormalConnection = true;
                                                    break;
                                                }

                                            }
                                        }

                                        if (!hasNormalConnection) {
                                            delete returnNodes[node];
                                        }

                                    }

                                } else if (scope.timeHash == "Edges") {

                                    //loop through all nodes, looking at all the edges that node has and then making sure not all edges have a timeHash with Decommissioned
                                    for (var node in allForceData.nodes) {

                                        var hasNormalEdge = false;
                                        for (var i=0; i< allForceData.nodes[node].inEdge.length; i++) {

                                            if (allForceData.nodes[node].inEdge[i].propHash.timeHash && allForceData.nodes[node].inEdge[i].propHash.timeHash["Decommissioned"]) {
                                                continue;
                                            }
                                            //assume we run into an edge that's not decommissioned
                                            else {
                                                hasNormalEdge = true;
                                                break;
                                            }

                                        }

                                        if (!hasNormalEdge) {
                                            for (var i = 0; i < allForceData.nodes[node].outEdge.length; i++) {

                                                if (allForceData.nodes[node].outEdge[i].propHash.timeHash && allForceData.nodes[node].outEdge[i].propHash.timeHash["Decommissioned"]) {
                                                    continue;
                                                }
                                                //assume we run into an edge that's not decommissioned
                                                else {
                                                    hasNormalEdge = true;
                                                    break;
                                                }

                                            }
                                        }

                                        if (hasNormalEdge) {
                                            returnNodes[node] = allForceData.nodes[node];
                                        }

                                    }
                                } else if (scope.timeHash == "Both") {
                                    var initialNodesSet = {};
                                    //loop through all nodes and remove the nodes and only add ones that do not get decommissioned
                                    for (var node in allForceData.nodes) {
                                        if (!allForceData.nodes[node].propHash.timeHash || (allForceData.nodes[node].propHash.timeHash && !allForceData.nodes[node].propHash.timeHash["Decommissioned"])) {
                                            initialNodesSet[node] = allForceData.nodes[node];
                                        }
                                    }

                                    //loop through the nodes and return nodes that have edges that aren't decommissioned and have connections with nodes that aren't decommissioned
                                    for (var node in initialNodesSet) {

                                        var hasNormalEdge = false;

                                        for (var i = 0; i < initialNodesSet[node].inEdge.length; i++) {

                                            var connectedNode = findNodeinAllNodes(initialNodesSet[node].inEdge[i].source);

                                            if ((initialNodesSet[node].inEdge[i].propHash.timeHash && initialNodesSet[node].inEdge[i].propHash.timeHash["Decommissioned"])
                                                    || (connectedNode.propHash.timeHash && connectedNode.propHash.timeHash["Decommissioned"])) {
                                                continue;
                                            }
                                            //assume we run into an edge that's not decommissioned
                                            else {
                                                hasNormalEdge = true;
                                                break;
                                            }

                                        }

                                        //if the inEdge array didn't have any normal edges check the outEdge
                                        if (!hasNormalEdge) {
                                            for (var i = 0; i < initialNodesSet[node].outEdge.length; i++) {

                                                var connectedNode = findNodeinAllNodes(initialNodesSet[node].outEdge[i].source);

                                                if ((initialNodesSet[node].outEdge[i].propHash.timeHash && initialNodesSet[node].outEdge[i].propHash.timeHash["Decommissioned"])
                                                        || (connectedNode.propHash.timeHash &&  connectedNode.propHash.timeHash["Decommissioned"])) {
                                                    continue;
                                                }
                                                //assume we run into an edge that's not decommissioned
                                                else {
                                                    hasNormalEdge = true;
                                                    break;
                                                }

                                            }
                                        }

                                        if (hasNormalEdge) {
                                            returnNodes[node] = initialNodesSet[node];
                                        }
                                    }

                                }


                                return returnNodes;
                            }

                            //remove edges
                            function removeEdges(linksToRemove) {

                                for (var j=0; j<linksToRemove.length; j++) {
                                    for (var i = 0; i < links.length; i++) {
                                        if (links[i].source.id == linksToRemove[j].source.id && links[i].target.id == linksToRemove[j].target.id) {
                                            links.splice(i, 1);
                                        }
                                    }
                                }
                            }

                            //remove node and all it's connected links
                            function removeNodes(nodesToRemove) {
                                for (var j=0; j<nodesToRemove.length; j++) {

                                    var i = 0,
                                            n = findNode(nodesToRemove[j]);
                                    while (i < links.length) {
                                        if ((links[i]['source'] == n)||(links[i]['target'] == n)) {
                                            links.splice(i,1);
                                        }
                                        else {
                                            i++;
                                        }
                                    }
                                    nodes.splice(findNodeIndex(nodesToRemove[j]),1);
                                }
                            }

                            //finds node in nodes array based on passed in 'id'
                            function findNodeIndex(id) {
                                for (var i in nodes) {if (nodes[i]["id"] === id) return i};
                            }

                            function updateEdgeColor(sliderValue) {
                                var dependICDs = [];

                                //looping through all links to find the dependent ICDs based on where the slider is
                                for (var i=0; i<nodes.length; i++) {
                                    if (nodes[i].propHash.timeHash && !nodes[i].propHash.timeHash["Decommissioned"]) {
                                        for (var phase in nodes[i].propHash.timeHash) {
                                            if (nodes[i].propHash.timeHash[phase].totalLOE < sliderValue && sliderValue > nodes[i].propHash.timeHash[phase].startLOE && phase == "Completed") {
                                                for (var icd in nodes[i].propHash.timeHash[phase].dependICDS) {
                                                    dependICDs.push(nodes[i].propHash.timeHash[phase].dependICDS[icd]);
                                                }
                                            }
                                        }
                                    }
                                }

                                //looping through all links to find the dependent ICDs based on where the slider is
                                for (var i=0; i<links.length; i++) {
                                    if (links[i].propHash.timeHash && !links[i].propHash.timeHash["Decommissioned"]) {
                                        for (var phase in links[i].propHash.timeHash) {
                                            if (links[i].propHash.timeHash[phase].totalLOE < sliderValue && sliderValue > links[i].propHash.timeHash[phase].startLOE && phase == "Completed") {
                                                for (var icd in links[i].propHash.timeHash[phase].dependICDS) {
                                                    dependICDs.push(links[i].propHash.timeHash[phase].dependICDS[icd]);
                                                }
                                            }
                                        }
                                    }
                                }

                                d3.selectAll(".link")
                                        .attr("stroke", function(d) {
                                            var color = getPhaseColor(d, sliderValue, dependICDs);
                                            return color ? color : '#666';
                                        });

                            }

                            function updateNodeColor(sliderValue) {
                                var dependICDs = [];

                                //looping through all links to find the dependent ICDs based on where the slider is
                                for (var i=0; i<nodes.length; i++) {
                                    if (nodes[i].propHash.timeHash && !nodes[i].propHash.timeHash["Decommissioned"]) {
                                        for (var phase in nodes[i].propHash.timeHash) {
                                            if (nodes[i].propHash.timeHash[phase].totalLOE < sliderValue && sliderValue > nodes[i].propHash.timeHash[phase].startLOE && phase == "Completed") {
                                                for (var icd in nodes[i].propHash.timeHash[phase].dependICDS) {
                                                    dependICDs.push(nodes[i].propHash.timeHash[phase].dependICDS[icd]);
                                                }
                                            }
                                        }
                                    }
                                }

                                //looping through all links to find the dependent ICDs based on where the slider is
                                for (var i=0; i<links.length; i++) {
                                    if (links[i].propHash.timeHash && !links[i].propHash.timeHash["Decommissioned"]) {
                                        for (var phase in links[i].propHash.timeHash) {
                                            if (links[i].propHash.timeHash[phase].totalLOE < sliderValue && sliderValue > links[i].propHash.timeHash[phase].startLOE && phase == "Completed") {
                                                for (var icd in links[i].propHash.timeHash[phase].dependICDS) {
                                                    dependICDs.push(links[i].propHash.timeHash[phase].dependICDS[icd]);
                                                }
                                            }
                                        }
                                    }
                                }



                                d3.selectAll(".node circle")
                                        .attr("fill", function(d) {
                                            var color = getPhaseColor(d, sliderValue, dependICDs);
                                            return color ? color : ("rgb(" + d.propHash.VERTEX_COLOR_PROPERTY + ")");
                                        });
                            }

                            function getPhaseColor(item, sliderValue, dependentICDs) {
                                var color;
                                if (item.propHash.timeHash) {

                                    if (item.propHash.timeHash["Decommissioned"]) {
                                        if (_.contains(dependentICDs, item.uri) || sliderValue >= scope.maxLoe) {
                                            color = "#FF0000";
                                        }
                                    } else {
                                        for (var phase in item.propHash.timeHash) {
                                            if (item.propHash.timeHash[phase].totalLOE >= sliderValue && sliderValue > item.propHash.timeHash[phase].startLOE) {

                                                if (phase == "Requirements") {
                                                    color = "#ECF6BD";
                                                } else if (phase == "Design") {
                                                    color = "#C5E5A0";
                                                } else if (phase == "Develop") {
                                                    color = "#9FD483";
                                                } else if (phase == "Test") {
                                                    color = "#79C366";
                                                } else if (phase == "Deploy") {
                                                    color = "#52B149";
                                                } else if (phase == "Completed") {
                                                    color = ("rgb(" + item.propHash.VERTEX_COLOR_PROPERTY + ")");
                                                }

                                            }
                                        }
                                    }
                                }

                                return color;
                            }

                            function calculateMaxLOE() {
                                var maxLOE = 0;
                                var tempTotal = 0;
                                var edgeLength = allForceData.edges.length;
                                var edgeHasTimeHash = false;

                                //check through the edges for timeHash and get maxLoe
	                            for (var i=0; i  < edgeLength; i++) {
                                    tempTotal = getTotalLOE(allForceData.edges[i]);

                                    if (tempTotal > maxLOE) {
                                        maxLOE = tempTotal;
                                    }
                                }

                                //check through the nodes for timeHash and get maxLoe
                                for (var node in allForceData.nodes) {
                                    tempTotal = getTotalLOE(allForceData.nodes[node]);

                                    if (tempTotal > maxLOE) {
                                        maxLOE = tempTotal;
                                    }
                                }

                                return maxLOE;
                            }

                            //adds the loe from all items in the timeHash if item has timeHash property
                            function getTotalLOE(item) {
                                var total = 0;
                                if (item.propHash.timeHash) {

                                    if (item.propHash.timeHash.Design) {
                                        total += item.propHash.timeHash.Design.LOE;
                                    }
                                    if (item.propHash.timeHash.Requirements) {
                                        total += item.propHash.timeHash.Requirements.LOE;
                                    }
                                    if (item.propHash.timeHash.Test) {
                                        total += item.propHash.timeHash.Test.LOE;
                                    }
                                    if (item.propHash.timeHash.Develop) {
                                        total += item.propHash.timeHash.Develop.LOE;
                                    }
                                    if (item.propHash.timeHash.Deploy) {
                                        total += item.propHash.timeHash.Deploy.LOE;
                                    }
                                }
                                return total;
                            }

                            //find node by 'id' within nodes array
                            function findNode(id) {
                                for (var i in nodes) {
                                    if (nodes[i]["id"] === id)
                                        return nodes[i];
                                };
                            }

                            //Please comment
                            function zoom() {
                                tick();
                            }

                            //Please comment
                            function tick() {
                                link.attr("d", linkArc);
                                node.attr("transform", function(d) {
                                    return "translate(" + xScale(d.x) + "," + yScale(d.y) + ")"; });
                            }

                            //create curved paths between nodes
                            function linkArc(d) {
                                var dx = xScale(d.target.x) - xScale(d.source.x),
                                        dy = yScale(d.target.y) - yScale(d.source.y),
                                        dr = Math.sqrt(dx * dx + dy * dy);
                                return "M" + xScale(d.source.x) + "," + yScale(d.source.y) + "A" + dr + "," + dr + " 0 0,1 " + xScale(d.target.x) + "," + yScale(d.target.y);
                            }

                            function resize() {
                                var newWidth = 0,
                                    newHeight = 0;

                                newWidth = parseInt(d3.select('#sidebarContentRight').style('width'));
                                newHeight = parseInt(d3.select('#sidebarContentRight').style('height'));


                                svg.attr("width", newWidth)
                                        .attr("height", newHeight);
                                rect.attr("width", newWidth)
                                        .attr("height", newHeight);
                                container.attr("width", width)
                                        .attr("height", newHeight);
                                force.size([newWidth, newHeight]).resume();
                            }

                            scope.$on('freeze-nodes', function() {
                                freezeAllNodes(d3.values(nodes));
                            });

                            scope.$on('unfreeze-nodes', function() {
                                unFreezeAllNodes(d3.values(nodes));
                            });

                            function freezeAllNodes(nodes) {
                                var nodesLength = nodes.length;

                                for (i=0; i < nodesLength; i++) {
                                    nodes[i].fixed = true;
                                }
                            }

                            function unFreezeAllNodes(nodes) {
                                var nodesLength = nodes.length;
                                for (i=0; i < nodesLength; i++) {
                                    nodes[i].fixed = false;
                                }
                                force.start();
                            }


                        }//end of link
                    }//end of return


            }).filter('reduceStringLength', function() {
                    //returns the string
                    return function(str, length) {

                        if (!length) {
                           length = 15;
                        }

                        if (str.length > length) {
                            return str.substring(0, length) + "...";
                        } else {
                            return str;
                        }
                    }
            }).filter('replaceUnderscores', function() {
                return function(str) {
                    str = String(str);
                    var myRe = new RegExp("([^/]*)$");
                    var shortStr = myRe.exec(str);
                    var result = shortStr[0].replace(/_/g, " ");

                    return result;
                }
            });



        //start(timeline_data);
    </script>
</body>
</html>