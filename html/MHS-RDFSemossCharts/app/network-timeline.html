<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Network Timeline</title>
    <link rel="stylesheet" type="text/css" href="css/ng-table.css">
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <link rel="stylesheet" type="text/css" href="css/tooltip.css">
    <link rel="stylesheet" href="css/d3.slider.css" />
    <link rel="stylesheet" href="css/network-timeline.css" />
</head>
<body ng-app="main">
    <div id="controllerID" ng-controller="NetworkCtrl">
        <div id="sidebarHeader">
            <div class="slider-container">
                <div id="slider"></div>
            </div>
        </div>
        <div id="sidebarContainer">
            <div id="sidebarContentArea">

                <div id="sidebarContentLeft">
                    <table ng-table="tableParams" show-filter="true" class="table fixed-layout">
                        <tr ng-repeat="item in $data track by $index">
                            <td data-title="'ICD'" class="icd" sortable="'name'" filter="{ 'name': 'text' }" header-class = "text-center">
                                {{item.name}}
                            </td>
                            <td title="{{user.phase}}" data-title="'Phase'" class="phase" sortable="'phase'" filter="{ 'phase': 'text' }" header-class = "text-center phase">
                                {{item.phase}}
                            </td>
                            <td title="{{user.LOE}}" data-title="'LOE'" class="loe" sortable="'loe'" filter="{ 'LOE': 'text' }" header-class = "text-center loe" class="text-right" >
                                {{item.LOE}}
                            </td>
                            <td title="{{user.gltag}}" data-title="'GL Tag'" class="gl-tag" sortable="'gltag'" filter="{ 'gltag': 'text' }" header-class = "text-center gl-tag" class="text-right" >
                                {{item.gltag}}
                            </td>
                        </tr>
                    </table>
                </div>

                <div id="sidebarContentRight">
                    <forcegraph data="forceData"></forcegraph>
                </div>

            </div>
            <div id="sidebarFooter"></div>
        </div>
    </div>
    <script src="lib/angular/angular_new.js"></script>
    <script src="js/ng-table.js"></script>

    <script type="text/javascript" src="lib/d3.v3.js"></script>
    <script type="text/javascript" src="lib/tooltip.js"></script>
    <script src="lib/jquery/jquery-1.11.0.min.js"></script>
    <script src="lib/jquery/jquery-ui.min.js"></script>
    <script src="lib/underscore.js"></script>
    <script src="lib/bootstrap-slider.js"></script>
    <script src="lib/d3.slider.js"></script>
    <script src="lib/taffy-min.js"></script>

    <script>

        function start(dataPassed) {

            var ctrlScope = angular.element(jQuery('#controllerID')).scope();
            // calling function in controller
            ctrlScope.setJSONData(dataPassed);

        };

        angular.module('main', ['ngTable']).
            controller('NetworkCtrl', function($scope, $filter, ngTableParams, $timeout, $rootScope) {
                    $scope.forceData = '';
                    $scope.tableData = [];
                    var tableDB;

//                    $timeout(function () {
//                        $scope.forceData = timeline_data;
//                        //createTableDataModel($scope.forceData.nodes);
//                        createTableDataModel($scope.forceData.edges);
//                    }, 500);

                    $scope.setJSONData = function (data) {
                        $scope.$apply(function () {
                            $scope.forceData = jQuery.parseJSON(data);
                            //createTableDataModel($scope.forceData.nodes);
                            createTableDataModel($scope.forceData.edges);
                        });
                    };

                    function createTableDataModel(array) {
                        var tableData = [];
                        for (var prop = 0; prop < array.length; prop++) {

                            if (array[prop].propHash.timeHash) {
	                            if(array[prop].propHash.timeHash["Decommissioned"]) { //decommissioned
                                    //new item data model
                                    var newItem = {
                                        name: array[prop].propHash.EDGE_NAME,
                                        phase: "Decommissioned",
                                        startLOE: 0,
                                        LOE: 0,
                                        totalLOE: 0,
                                        dependICDS: "",
                                        gltag: ""
                                    };

                                    tableData.push(newItem);
                                } else { //requirements, design, test, develop, deploy phases

                                    //create total for LOE hours
                                    var totalLOE = 0;
                                    var phases = ["Requirements", "Design", "Develop", "Test", "Deploy"];

		                            for(var i=0; i<phases.length; i++) {
                                        if (array[prop].propHash.timeHash[phases[i]]) {



                                            //new item data model
                                            var newItem = {};
                                            newItem.name = array[prop].propHash.EDGE_NAME;
                                            newItem.phase = array[prop].propHash.timeHash[phases[i]].phase;
                                            newItem.startLOE = totalLOE;
                                            newItem.LOE = array[prop].propHash.timeHash[phases[i]].LOE;
                                            //set the edges properties
                                            array[prop].propHash.timeHash[phases[i]].startLOE = totalLOE;

                                            //add to previous total
                                            totalLOE += array[prop].propHash.timeHash[phases[i]].LOE;

                                            //set the edges properties
                                            array[prop].propHash.timeHash[phases[i]].totalLOE = totalLOE;
                                            newItem.totalLOE = totalLOE;
                                            newItem.dependICDS = array[prop].propHash.timeHash[phases[i]].dependICDS;
                                            newItem.gltag = array[prop].propHash.timeHash[phases[i]].gltag;




                                            tableData.push(newItem);
                                        }
                                    }

                                    var newItem = {
                                        name: array[prop].propHash.EDGE_NAME,
                                        phase: "Completed",
                                        startLOE: totalLOE,
                                        LOE: 0,
                                        totalLOE: 500,
                                        dependICDS: array[prop].propHash.timeHash["Requirements"].dependICDS,
                                        gltag: ""
                                    };
                                    array[prop].propHash.timeHash["Completed"] = newItem;

                                    tableData.push(newItem);
	                            }
                            } else {
                                //new item data model
                                var newItem = {
                                    name: array[prop].propHash.EDGE_NAME,
                                    phase: "N/A",
                                    startLOE: 0,
                                    LOE: 0,
                                    totalLOE: 0,
                                    dependICDS: "",
                                    gltag: ""
                                };
                                tableData.push(newItem);
                            }

                        } //end of forloop

                        tableDB = TAFFY(tableData);

//
                    }

                    function setTableData(sliderValue) {
                        $scope.tableData = tableDB(function() {
                            return this.totalLOE >= sliderValue && sliderValue > this.startLOE;
                        }).get();

                        $scope.tableParams.count($scope.tableData.length);
                        $scope.tableParams.reload();
                    }

                    $rootScope.$on('slider-change', function(event, sliderVal) {
                        console.log(sliderVal);
                        setTableData(sliderVal);
                    });

                    function getTableData() {
                        if ($scope.tableData) {
                            return $scope.tableData;
                        } else {
                            return [];
                        }
                    }

                    $scope.tableParams = new ngTableParams({
                        count: getTableData().length,          // count per page
                        sorting: {
                            phase: 'asc'     // initial sorting
                        }
                    }, {
                        counts: [],
                        total: getTableData().length, // length of data
                        getData: function($defer, params) {
                            var data = getTableData();
                            // use build-in angular filter
                            var filteredData = params.filter() ?
                                    $filter('filter')(data, params.filter()) :
                                    data;
                            var orderedData = params.sorting() ?
                                    $filter('orderBy')(filteredData, params.orderBy()) :
                                    data;
                            params.total(orderedData.length); // set total for recalc pagination
                            $defer.resolve(orderedData.slice((params.page() - 1) * params.count(), params.page() * params.count()));
                        }
                    });
            }).
            directive('forcegraph', function($rootScope) {
                    return {
                        restrict: 'AE',
                        scope: {
                            data: '=',
                            containerClass: "=",
                            labels: "="
                        },
                        link: function (scope, ele, attrs) {
                            var links = [],
                                    nodes = [],
                                    newNodes = [],
                                    newLinks = [],
                                    obj = {},
                                    linkedByIndex = {},
                                    legendNodes = [],
                                    margin = {top: 100, right: 100, bottom: 100, left: 100},
                                    container = {width: 0, height: 0},
                                    maxLOE = 0,
                                    minLOE = 0;

                            //TODO: this needs to be refactored to use container and margin objects
                            var width = 0;
                            var height = 0;
                            width = parseInt(d3.select('#sidebarContentRight').style('width'));
                            height = parseInt(d3.select('#sidebarContentRight').style('height'));

                            scope.$watch('data', function() {
                                if (!_.isEmpty(scope.data)) {

                                    newNodes = scope.data.nodes;
                                    newLinks = scope.data.edges;

                                    for (var prop in newNodes) {
                                        obj = $.extend({}, newNodes[prop]);
                                        obj.id = prop;
                                        nodes.push(obj);
                                    }
                                    newLinks.forEach(function (link) {
                                        //depending on if the link.source & link.target are already pointing to
                                        //strings or object instances
                                        link.source = findNode(link.source) || findNode(link.source.id);
                                        link.target = findNode(link.target) || findNode(link.target.id);
                                        links.push(link);
                                    });

                                    calculateMaxLOE();

                                    d3.select('#slider')
                                        .call(
		                                    d3.slider().axis(true).min(minLOE).max(maxLOE+1).step(2).value(0)
			                                    .on('slide', function (e, v) {
                                                    scope.$emit('slider-change', v);
                                            }));
                                    update();
                                }

                            });

                            $rootScope.$on('slider-change', function(event, sliderVal) {
                                updateEdges(sliderVal);
                            });

                            var xScale = d3.scale.linear()
                                    .domain([0, width])
                                    .range([0, width]);

                            var yScale = d3.scale.linear()
                                    .domain([0, height])
                                    .range([0, height]);

                            var rScale = d3.scale.linear()
                                    .rangeRound([8, 16])
                                    .nice();

                            var lScale = d3.scale.linear()
                                    .range([1.5, 4.5]);

                            /*** Configure zoom behaviour ***/
                            //        var zoomer = d3.behavior.zoom()
                            //                .scaleExtent([0.1,10])
                            //                .x(xScale)
                            //                .y(yScale)
                            //                .on("zoom", zoom);

                            var force = d3.layout.force()
                                    .size([width, height])
                                    .gravity(.09) //attraction to the center of the screen and within the screen layout
                                    .linkDistance(60)
                                    .charge(-200) //amount of node repulsion(negative) or attraction(positive)
                                    .on("tick", tick);

                            var drag = force.drag()
                                    .origin(function (d) {
                                        return d;
                                    }); //center of circle
//                .on("dragstart", dragstarted)
//                .on('drag.force', dragged)
//                .on("drag", dragged)
//                .on("dragend", dragended);

                            var svg = d3.select(ele[0]).append("svg")
                                    .attr("width", width)
                                    .attr("height", height);

                            var graph = svg.append("g")
                                    .attr("class", "graph");
//                .call(zoomer); //Attach zoom behaviour.

                            var rect = graph.append("rect")
                                    .attr("width", width)
                                    .attr("height", height)
                                    .style("fill", "none")
                                //make transparent (vs black if commented-out)
                                    .style("pointer-events", "all");
                            //respond to mouse, even when transparent

                            var vis = graph.append("g")
                                    .attr("class", "plotting-area");

                            // Per-type markers, as they don't inherit styles.
                            var defs = vis.append("defs").selectAll("marker")
                                    .data(["end"])
                                    .enter().append("marker")
                                    .attr("id", function (d) {
                                        return d;
                                    })
                                    .attr("viewBox", "0 -5 10 10")
                                    .attr("refX", 15)
                                    .attr("refY", -1.5)
                                    .attr("markerWidth", 6)
                                    .attr("markerHeight", 6)
                                    .attr("orient", "auto")
                                    .append("path")
                                    .attr("d", "M0,-5L10,0L0,5")
                                    .style("pointer-events", "none"); //no events need to be fired off of marker

                            //add legend
                            var legendBox = svg.append("g")
                                    .attr("class", "legend")
                                    .attr("height", 100)
                                    .attr("width", 100);

                            var container = svg.append("g");

                            var node = vis.selectAll(".node"),
                                    link = vis.selectAll(".link");

                            nodes = force.nodes();
                            links = force.links();

                            function update() {
                                /*** Configure zoom behaviour ***/
                                var zoomer = d3.behavior.zoom()
                                        .scaleExtent([0.1,10])
                                        .x(xScale)
                                        .y(yScale)
                                        .on("zoom", zoom);
                                //set up legendNodes array for legend
                                var flags = {};
                                legendNodes = nodes.filter(function(node) {
                                    if (flags[node.propHash.VERTEX_TYPE_PROPERTY]) {
                                        return false;
                                    }
                                    flags[node.propHash.VERTEX_TYPE_PROPERTY] = true;
                                    return true;
                                });

                                //highlight adjacent -> will be moved to a click event
                                links.forEach(function(d) {
                                    linkedByIndex[d.source.id + "," + d.target.id] = 1;
                                });

                                //link update...
                                link = link.data(links, function(d) {
                                    return d.source.id + "-" + d.target.id;
                                });

                                //link enter...
                                link.enter()
                                        .insert("path", ".node") //paths should always be placed before the group of nodes/text
                                        .attr("class", "link")
                                        .attr("marker-end", function(d) { return "url(#end)"; })
                                        .attr("id", function(d, i) { return "linkId_" + i; })
                                        .attr("fill", "none")
                                        .attr("stroke", "#666")
                                        .attr("stroke-width", 1.5);

                                //link exit...
                                link.exit()
                                        .transition().duration(500)
                                        .remove();

                                //node update...
                                node = node.data(nodes, function(d) {
                                    return d.id;
                                });

                                //node enter g...
                                var nodeEnter = node.enter().append("g")
                                        .attr("class", function(d) { return "node " + d.id; })
                                        .call(drag);

                                //node enter circle...
                                nodeEnter.append("circle")
                                        .attr("class", "node")
                                        .attr("r", 0).transition().duration(1000)
                                        .attr("r", 8)
                                        .attr("fill", function(d){
                                            return ("rgb(" + d.propHash.VERTEX_COLOR_PROPERTY + ")")
                                        })
                                        .attr("stroke", "#777")
                                        .attr("stroke-width", 1.5)
                                        .attr("data-legend", function(d) {
                                            return d.propHash.VERTEX_COLOR_PROPERTY;
                                        });

                                //node enter text...
                                nodeEnter.append("text")
                                        .attr("class", "nodetext")
                                        .attr("x", 12)
                                        .attr("dy", ".35em")
                                        .attr("stroke", "none")
                                        .style("font-size", "10px")
                                        .text(function(d) {
                                            return d.propHash.VERTEX_TYPE_PROPERTY;
                                        });

                                //node group removal with transition...
                                node.exit()
                                        .selectAll("circle")
                                        .transition().duration(1000)
                                        .attr("r", 0)
                                        .remove();
                                node.exit()
                                        .selectAll("text")
                                        .transition().duration(1000)
                                        .style("font-size","0px")
                                        .remove();
                                node.exit().transition().delay(1000).remove();

                                //legend update...
                                var legend = legendBox.selectAll('circle')
                                        .data(legendNodes, function(d) {
                                            return d.propHash.VERTEX_TYPE_PROPERTY;
                                        });

                                //legend enter...
                                legend.enter()
                                        .append("circle")
                                        .attr("r", 0)
                                        .transition().duration(1000)
                                        .attr("r", 6)
                                        .attr("stroke-width", 1)
                                        .attr("stroke", function(d) {
                                            return ("rgb(" + d.propHash.VERTEX_COLOR_PROPERTY + ")");
                                        })
                                        .attr("transform", function(d, i) { return "translate(20," + ((i * 20) + 15) + ")"; })
                                        .style("fill", function(d) {
                                            return ("rgb(" + d.propHash.VERTEX_COLOR_PROPERTY + ")");
                                        });

                                //legend exit...(move below with legendText exit?)
                                legend.exit().transition()
                                        .attr("r", 0)
                                        .remove();

                                //legendText update...
                                var legendText = legendBox.selectAll('text')
                                        .data(legendNodes, function(d) {
                                            return d.propHash.VERTEX_TYPE_PROPERTY;
                                        });

                                //legendText enter...
                                legendText.enter()
                                        .append("text")
                                        .transition().duration(1000)
                                        .attr("x", 12)
                                        .attr("transform", function(d, i) { return "translate(20," + ((i * 20) + 19) + ")"; })
                                        .text(function(d) {
                                            return d.propHash.VERTEX_TYPE_PROPERTY;
                                        });

                                //legendText exit...
                                legendText.exit().transition()
                                        .remove();

                                var legendTextArray = [];
                                //setting array of just the name values of each type, then sending them to a controller function
                                for (var i=0; i< legendNodes.length; i++) {
                                    legendTextArray.push(legendNodes[i].propHash.VERTEX_TYPE_PROPERTY);
                                }

                                //need to combine this selectALL and the bottom selectAll into one group
                                d3.select(".legend").selectAll("text")
                                        .style("cursor", "pointer")
                                        .on("click", function(d) {
                                            legendClick(d);
                                        });

                                d3.select(".legend").selectAll("circle")
                                        .style("cursor", "pointer")
                                        .on("click", function(d) {
                                            legendClick(d);
                                        });

                                force.start();
                            }

                            function updateEdges(sliderValue) {
                                var dependICDs = [];

                                for (var i=0; i<links.length; i++) {
                                    if (links[i].propHash.timeHash) {
                                        if (!links[i].propHash.timeHash["Decommissioned"]) {
                                            for (var phase in links[i].propHash.timeHash) {
                                                if (links[i].propHash.timeHash[phase].totalLOE > sliderValue && sliderValue > links[i].propHash.timeHash[phase].startLOE && phase == "Completed") {
                                                    dependICDs.push(links[i].propHash.timeHash[phase].dependICDS);
                                                }
                                            }
                                        }
                                    }
                                }

                                d3.selectAll(".link")
                                    .attr("stroke", function(d) {

                                        var color = "#666";
                                        if (d.propHash.timeHash) {

                                            if (d.propHash.timeHash["Decommissioned"]) {
                                                if (_.contains(dependICDs, d.uri) || sliderValue >= maxLOE) {
                                                    color = "#FF0000";
                                                }
                                            } else {
                                                for (var phase in d.propHash.timeHash) {
                                                    if (d.propHash.timeHash[phase].totalLOE >= sliderValue && sliderValue > d.propHash.timeHash[phase].startLOE) {

                                                        if (phase == "Requirements") {
                                                            color = "#FF9900";
                                                        } else if (phase == "Design") {
                                                            color = "#D6A314";
                                                        } else if (phase == "Develop") {
                                                            color = "#ADAD29";
                                                        } else if (phase == "Test") {
                                                            color = "#85B83D";
                                                        } else if (phase == "Deploy") {
                                                            color = "#5CC252";
                                                        } else if (phase == "Completed") {
                                                            color = "#33CC66";

                                                        }

                                                    }
                                                }
                                            }
                                        }
                                        return color;
                                    });
                            }

                            function calculateMaxLOE() {

	                            for (var i=0; i  < links.length; i++) {
                                    if (links[i].propHash.timeHash) {
                                        var total = 0;
                                        if (links[i].propHash.timeHash.Design) {
                                            total += links[i].propHash.timeHash.Design.LOE;
                                        }
                                        if (links[i].propHash.timeHash.Requirements) {
                                            total += links[i].propHash.timeHash.Requirements.LOE;
                                        }
                                        if (links[i].propHash.timeHash.Test) {
                                            total += links[i].propHash.timeHash.Test.LOE;
                                        }
                                        if (links[i].propHash.timeHash.Develop) {
                                            total += links[i].propHash.timeHash.Develop.LOE;
                                        }
                                    }

                                    if (total > maxLOE) {
                                        maxLOE = total;
                                    }
                                }

                            }

                            //find node by 'id' within nodes array
                            function findNode(id) {
                                for (var i in nodes) {
                                    if (nodes[i]["id"] === id)
                                        return nodes[i]
                                };
                            }

                            //Please comment
                            function zoom() {
                                tick();
                            }

                            //Please comment
                            function tick() {
                                link.attr("d", linkArc);
                                node.attr("transform", function(d) {
                                    return "translate(" + xScale(d.x) + "," + yScale(d.y) + ")"; });
                            }

                            //create curved paths between nodes
                            function linkArc(d) {
                                var dx = xScale(d.target.x) - xScale(d.source.x),
                                        dy = yScale(d.target.y) - yScale(d.source.y),
                                        dr = Math.sqrt(dx * dx + dy * dy);
                                return "M" + xScale(d.source.x) + "," + yScale(d.source.y) + "A" + dr + "," + dr + " 0 0,1 " + xScale(d.target.x) + "," + yScale(d.target.y);
                            }


                        }//end of link
                    }//end of return
            }).filter('reduceStringLength', function() {
                    //returns the string
                    return function(str, length) {
                
                        if (!length) {
                           length = 15;
                        }
                
                        if (str.length > length) {
                            return str.substring(0, length) + "...";
                        } else {
                            return str;
                        }
                    }
            }).filter('replaceUnderscores', function() {
                return function(str) {
                    str = String(str);
                    var myRe = new RegExp("([^/]*)$");
                    var shortStr = myRe.exec(str);
                    var result = shortStr[0].replace(/_/g, " ");
                    
                    return result;
                }
            });



        //start(timeline_data);
    </script>
</body>
</html>