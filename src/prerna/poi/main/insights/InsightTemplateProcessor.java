package prerna.poi.main.insights;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import prerna.algorithm.impl.AlgorithmDataFormatter;
import prerna.poi.main.TextExtractor;
import prerna.util.DIHelper;
import prerna.util.PlaySheetRDFMapBasedEnum;

public class InsightTemplateProcessor {
	
	public InsightTemplateProcessor() {

	}

	/**
	 * Test main method for processing a template file
	 * @param args
	 */
//	public static void main(String[] args) {
//		String filePath = "C:\\Users\\mahkhalil\\workspace\\Semoss_Dev\\db\\Default\\Default_AutoGenerated_Insights.prop";
//		InsightTemplateProcessor processor = new InsightTemplateProcessor();
//		try {
//			List<String> questionRules = processor.splitRules(filePath);
//			List<InsightRule> rules = processor.processRules(questionRules);
//			int i = 0;
//			int size = rules.size();
//			for(; i < size; i++) {
//				InsightRule rule = rules.get(i);
//				System.out.println("Question: " + rule.getQuestion());
//				System.out.println("Variables: " + rule.getVariableTypeHash());
//				System.out.println("Output: " + rule.getOutput());
//				System.out.println("Has aggregation: " + rule.isHasAggregation());
//				System.out.println("Constraints: " + rule.getConstraints());
//				System.out.println("\n");
//			}
//		} catch (IOException e) {
//			e.printStackTrace();
//		}
//	}
	
	/**
	 * Gets the path for the default insights and generates a list of rules
	 * @return
	 */
	public List<InsightRule> runGenerateInsights() {
		String filePath = DIHelper.getInstance().getProperty("BaseFolder") + "\\db\\Default\\Default_AutoGenerated_Insights.prop";
		List<InsightRule> rules = new ArrayList<InsightRule>();
		try {
			List<String> questionRules = splitRules(filePath);
			rules = processRules(questionRules);
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return rules;
	}
	
	/**
	 * Processes through the list of questions as strings to generate a list of insight rule objects
	 * @param questionRules 	The list of questions as strings
	 * @return					The list of rules
	 */
	public List<InsightRule> processRules(List<String> questionRules) {
		List<InsightRule> rules = new ArrayList<InsightRule>();
		NEXT_QUESTION: for(String question : questionRules) {
			String[] questionSplit = question.split("\n+|\r+");
			InsightRule rule = new InsightRule();
			int i = 1;
			int size = questionSplit.length - 2;
			for(; i < size; i++) {
				String rulePart = questionSplit[i];
				if(!rulePart.isEmpty()) {
					if(rulePart.toUpperCase().startsWith(InsightRuleConstants.QUESTION_KEY)) {
						String[] questionRuleSplit = rulePart.split("=");
						rule.setQuestion(questionRuleSplit[1].replace("@", "").trim());
						
						String questionRegex = "\\$(.+?)(\\s|\\?|\\.|\\n|\\r)";
						Pattern pattern = Pattern.compile(questionRegex);
						Matcher matcher = pattern.matcher(rulePart);
						while(matcher.find()) {
							String variableName = matcher.group();
							variableName = variableName.substring(1, variableName.length()-1);
							String variableType = null;
							if(variableName.toUpperCase().contains(InsightRuleConstants.CENTRAL_CONCEPT_VALUE)) {
								rule.setCentralConcept(variableName);
							}else {
								if(variableName.toUpperCase().contains(InsightRuleConstants.CONCEPT_VALUE)) {
									variableType = InsightRuleConstants.CONCEPT_VALUE;
								} else if(variableName.toUpperCase().contains(InsightRuleConstants.PROPERTY_VALUE)) {
									variableType = InsightRuleConstants.PROPERTY_VALUE;
								} else {
									continue NEXT_QUESTION;
								}
								rule.addVariable(variableName, variableType);
							}
						}
						
					} else if(rulePart.toUpperCase().startsWith(InsightRuleConstants.OUTPUT_KEY)) {
						String[] outputRuleSplit = rulePart.split("=");
						outputRuleSplit[1] = outputRuleSplit[1].replaceAll("_", " ").trim();
						String psClass = PlaySheetRDFMapBasedEnum.getClassFromName(outputRuleSplit[1]);
						if(!psClass.isEmpty()) {
							rule.setOutput(outputRuleSplit[1]);
						} else {
							// if output not found above, then go to next question
							continue NEXT_QUESTION;
						}
					} else if(rulePart.toUpperCase().startsWith(InsightRuleConstants.PERSPECTIVE_KEY)) {
						String[] perspectiveRuleSplit = rulePart.split("=");
						rule.setPerspective(perspectiveRuleSplit[1].trim());
					} else {
						String[] paramSplit = rulePart.split("-");
						String[] constraintValueSplit = paramSplit[1].split("=");
						constraintValueSplit[0] = constraintValueSplit[0].toUpperCase();
						constraintValueSplit[1] = constraintValueSplit[1].toUpperCase();
						// change boolean value if aggregation is used
						if(constraintValueSplit[1].equals(InsightRuleConstants.COUNT) || 
								constraintValueSplit[1].equals(InsightRuleConstants.SUM) || 
								constraintValueSplit[1].equals(InsightRuleConstants.AVERAGE) || 
								constraintValueSplit[1].equals(InsightRuleConstants.MIN) || 
								constraintValueSplit[1].equals(InsightRuleConstants.MAX)) 
						{
							rule.setHasAggregation(true);
							constraintValueSplit[0] = InsightRuleConstants.AGGREGATION;
							rule.addConstraint(paramSplit[0].replace("@", "").trim(), constraintValueSplit[0].trim(), constraintValueSplit[1].trim());
						} else if(constraintValueSplit[0].equalsIgnoreCase(InsightRuleConstants.DATA_TYPE) && 
								(constraintValueSplit[1].equalsIgnoreCase(AlgorithmDataFormatter.STRING_KEY) ||
								constraintValueSplit[1].equalsIgnoreCase(AlgorithmDataFormatter.DOUBLE_KEY)  ||
								constraintValueSplit[1].equalsIgnoreCase(AlgorithmDataFormatter.SIMPLEDATE_KEY)  ||
								constraintValueSplit[1].equalsIgnoreCase(AlgorithmDataFormatter.DATE_KEY ) ) )
						{
							rule.addConstraint(paramSplit[0].replace("@", "").trim(), constraintValueSplit[0].trim(), constraintValueSplit[1].trim());
						}else {
							Double val = null;
							try {
								val = Double.parseDouble(constraintValueSplit[1].trim());
							} catch(NumberFormatException ex) {
								continue NEXT_QUESTION;
							}
							rule.addConstraint(paramSplit[0].replace("@", "").trim(), constraintValueSplit[0].trim(), val);
						}
					}
				}
			}
			// only use questions if question string and output is defined and at least one constraint
			if(!rule.getQuestion().isEmpty() && !rule.getOutput().isEmpty() && !rule.getConstraints().isEmpty()) {
				rules.add(rule);
			}
		}
		return rules;
	}

	/**
	 * Returns a list of strings where each string represents an insight question
	 * @param filePath			The path to the insight default template
	 * @return					The list of questions as strings
	 * @throws IOException
	 */
	public List<String> splitRules(String filePath) throws IOException {
		final String regex = "<Question>(.+?)</Question>";

		String fileContent = TextExtractor.readFile(filePath, StandardCharsets.UTF_8);
		final Pattern pattern = Pattern.compile(regex, Pattern.DOTALL);
		final Matcher matcher = pattern.matcher(fileContent);
		
		List<String> questionRules = new ArrayList<String>();
		while(matcher.find()) {
			questionRules.add(matcher.group());
		}
		
		return questionRules;
	}
}
