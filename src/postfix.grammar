Package prerna.sablecc;

Helpers
 alpha = [['a' .. 'z'] + ['A' .. 'Z']];
 letter_s = ['a' .. 'z'];
 letter_b = ['A' .. 'Z'];
 digit = ['0' .. '9'];
 underscore = '_';
 hdot = '.';
 

Tokens
 number = ['0' .. '9']+;
 id = (letter_s | letter_b | digit | underscore)*;
dot = '.';
 semicolon = ';';
 colon = ':';
 plus = '+';
 minus = '-';
 mult = '*';
 comma = ',';
 quote = ('"' | ''');
 div = '/';
 col = 'col';
 comparator = ('>' | '<' | '<=' | '>=' | '=' | '!=' | 'like');
 coladd = 'col.add';
 //('addColumn:'|'ac:'|'a:'|'add:' | 'col');
 api = ('api:'|'call:');
 math = ('math.' | 'm.');
 coljoin = 'col.join';
 colprefix = 'c:';
 table_prefix = 't:';
 valprefix = 'v:';
 colremove = 'col.remove';
 colfilter = 'col.filter';
 colunfilter = 'col.unfilter';
 colimport = 'col.import';
 //('removeColumn:' | 'rm:' | 'del:' | 'rem:');
 colset = 'col.set';
 //('setColumn:' | 'sc:' | 'set:');
 colpivot = 'col.pivot';
 colfocus = 'col.focus';
 colalias = 'col.alias';
 //('pivotColumn:' | 'pivot:' | 'pc:');
 collink = 'link:';
 show_hide = ('on' | 'off');
 mod = '%';
 l_par = '(';
 r_par = ')';
 l_bracket = '[';
 r_bracket = ']';
 l_curl_bracket = '{';
 r_curl_bracket = '}';
 group = 'group:';
 blank = (' ' | 13 | 10)+;
 space = (' ' | 13)+;
 equal = '=';
 newline = '\r'? '\n';
 java = 'j:';
 r = 'r:';
 python = 'p:';
 proc = 'm:'; // | 'average');
 this = 'this';
 null = 'null';
 import_type = ('flat' | 'tree');
 rel_type = ('inner.join' | 'outer.join' | 'right.outer.join' | 'left.outer.join' | 'cross.join' | 'self.join' ); 
 dataimporttoken = 'data.import';
 dataremovetoken = 'data.remove';
 literal = (letter_s | letter_b | digit | underscore)*;// | special)*;
 help_token = 'info.help';
 vizchange = 'viz.change';
 vizcomment = 'viz.comment';
 alphanumeric = [0 .. 0xFFFF];
 
 
Ignored Tokens
 blank;

Productions
configuration = script*;

script = {colop} colop  semicolon // column operations
		 | {varop} varop semicolon// row operations or setting up data
		 | {r_op} r_op semicolon// call to CRAN
		 //| {j_op} j_op semicolon// java operation
		 | {expr} expr semicolon
		 //| statop
		 | {help} help semicolon
		 | {vizop} vizop semicolon
		 | newline
		 ;

colop = // colOp is usually of the form of joinColumn / addColumn / removeColumn / setColumn
		{add_column} add_column 
		| {remcol} rem_column 
		| {setcol} set_column
		| {pivotcol} pivot_column
		| {filtercol} filter_column
		| {focuscol} focus_column
		| {unfocus} unfocus
		| {import} import_column
		| {alias} alias_column
		| {import_data} import_data
		| {unfiltercol} unfilter_column
		| {remove_data} remove_data
		;

vizop = // vizop is usually of the form of viz.change, viz.tools, viz.color
		{viz_change} viz_change 
		| {viz_comment} viz_comment
		;

viz_change = // e.g. viz.change(bar, [c:Title, c:Budget]); vizchange( vizType, ordered headers );
		vizchange l_par [layout]:id comma [datatablealign]:col_csv r_par
		;
		
viz_comment = // e.g. viz.comment("this looks super important", group0, coordinate, (50, 16));
		vizcomment l_par [text]:word [c1]:comma [group]:id [c2]:comma [type]:id [c3]:comma [location]:word_or_num r_par
		;
		
add_column = // follows the pattern of addColumn(columnName and optionally the expression) addColumn(c:NewCol, 'expression', [c:col1, c:col2]);
		coladd l_par [newcol]:col_def comma [expr]:expr r_par 
		;

rem_column = // follows the pattern of addColumn(columnName and optionally the expression) removeColumn(c:colToRemove);
		colremove l_par [newcol]:col_def col_group* r_par 
		;

set_column = // follows the pattern of addColumn(columnName and optionally the expression) addColumn(c:NewCol, 'expression');
		colset l_par [newcol]:col_def comma [expr]:expr r_par 
		;

pivot_column = // grouping based on multiple columns
		colpivot l_par [firstcol]:col_def col_group+ r_par;

filter_column = // filter column using an expression
		colfilter l_par [where]:where_clause r_par;

unfilter_column = //unfilter column using col_def
		colunfilter l_par col_def r_par;
		
focus_column = // takes all the other columns and focuses on only these columns
		colfocus l_par col_def col_group* show_hide r_par
		;
		
unfocus = // you will specify it as col.focus('off');
		colfocus l_par show_hide r_par
		;

import_column = // importing data - col.import(tree | flat, [c:col1, c:col2, c:col3], [ [1,2,3] [a,b,c] ] - this is a flat
		colimport [lp1]:l_par [cols]:col_csv [relations]:relation_clause? [rp2]:r_par dot [data]:csv_table 
		;

alias_column = // sets the column aliases
		colalias [lp1]:l_par [cols]:col_csv [where]:where_statement [rp2]:r_par;
		
import_data = // imports from api query commands and other scripts
		dataimporttoken [lp1]:l_par [api]:api_block [joins]:relation_clause? [rp2]:r_par;

remove_data = // imports from api query commands and other scripts and deletes that data from the table
		dataremovetoken l_par api_block relation_clause? r_par; 

decimal = [whole]:number dot? [fraction]:number?;
		
expr_group = [comma]:comma [expr]:expr;		

api_block = api [engine_name]:id dot [insight]:id l_par [selectors]:col_csv [where]:where_statement? [relations]:relation_clause? r_par; // the insight can also be the method
// query format
// api:Tap_Core.Query:([Selectors], [Filters], [relations])
// relations
// selector sibling selector comes from the same table
// selector comparator selector

selector = l_bracket col_csv r_bracket;

codeblock = l_curl_bracket alphanumeric* r_curl_bracket;

// where column clause
col_where = col_def comparator col_def_or_csv_row;

col_def_or_csv_row = {col_def} col_def | {csv} csv_row;

col_where_group = comma col_where;

//where_clause = comma? l_par col_where col_where_group* r_par; // , (
where_clause = col_where col_where_group*;

where_statement = comma? l_par where_clause r_par;
// relations
relation_def = l_bracket [from]:col_def [com1]:comma rel_type [com2]:comma [to]:col_def r_bracket;

relation_group = comma relation_def;

relation_clause = comma l_par relation_def relation_group* r_par;

if_block = l_par comparator comma term r_par;

col_group = comma col_def;

group_by = l_par col_def col_group* r_par; // this is to be included in various math calculations (Studio, Genre) - this is equivalent of saving pivot on this

col_def = colprefix [colname]:id;

table_def = table_prefix [cardinality]:number; // if you want to add runtime formulas as you take the table in - instead of waiting

var_def = valprefix [valname]:id;

varop = // variable operation usually takes the form of a given variable taking ID = some stuff
		 [name]:var_def equal [expr]:expr 
		;
		
//num_csv = l_bracket decimal num_csv_group+ r_bracket; 		

csv_row = l_bracket word_or_num csv_group* r_bracket; 		// [1,3]

easy_row = word_or_num easy_group+ newline;

easy_group = comma word_or_num;

csv_table = l_bracket csv_row+ r_bracket; //[[1,3][2,4][5,6]]

col_csv = l_bracket col_def col_group* r_bracket; // this is typically of the form [c:col1, c:col2, c:col3]

word_or_num = {num} decimal | {alpha} word |{expr} [formula]:formula ; // I need some way putting an expression here

word = [l]:quote word_or_blank+ [r]:quote;

word_or_blank = {id} id | number | {blank} space;

formula = l_par expr r_par;
		
csv_group = comma [csv]:word_or_num; // , 3

expr_row = l_bracket [expr]:expr expr_group* r_bracket;

j_op = // this of the pattern j:{hola, hello etc.. }
	java codeblock;
	
r_op = r codeblock;

help = help_token;
		
 expr =
  {term} term
  | {plus} [left]:term plus [right]:term
  | {minus} [left]:term minus [right]:term
  | {mult} [left]:term mult [right]:term |
  | {div} [left]:term div [right]:term 
  | {mod} [left]:term mod [right]:term
  | {e_expr} extended_expr
  //|{math_fun} math_fun // I need to still resolve other mathematical functions
  ;
 
 math_fun = proc id l_par [expr]:expr_row comma? [group]:col_csv? r_par; // m.Sum([1 + c:Activity], /*groupBy*/(c:studio, c:genre));
 
 extended_expr = l_par [expr]:expr comma? [group]:col_csv r_par; // I have no idea why I need this.. but !!
 
 term =
  {number} decimal |
  {expr} l_par expr r_par 
  | {var} valprefix [var]:id
  | {col} [col]:col_def
  | {api} api_block
  | {tab} [tab]:table_def
  | {wcsv} csv_row
  | null
  |  {alpha} word
  | {math_fun} math_fun
  //| {r} r_op //Include in term only if we want a user to be able to do column operations with result from R code
  ;