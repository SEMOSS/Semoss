Package prerna.sablecc;

Helpers
 alpha = [['a' .. 'z'] + ['A' .. 'Z']];
 letter_s = ['a' .. 'z'];
 letter_b = ['A' .. 'Z'];
 digit = ['0' .. '9'];
 underscore = '_';
 hdot = '.';
 alphanumeric = [0 .. 0xFFFF];
 quote = ('"' | ''');
 not_quote = [alphanumeric - ['"' + ''']];
 panelprefix =  'panel' ( '[' digit ']' )?;
 panelcommentprefix = panelprefix '.comment' ( '[' digit ']' )?;
 code = '<code>';
 

Tokens
 number = ['0' .. '9']+;
 id = (letter_s | letter_b | digit | underscore | '-')*;
 dot = '.';
 semicolon = ';';
 colon = ':';
 plus = '+';
 minus = '--';
 mult = '*';
 comma = ',';
 div = '/';
 col = 'col';
 comparator = ('>' | '<' | '<=' | '>=' | '=' | '!=' | 'like');
 coladd = 'col.add';
 api = ('api:'|'call:');
 math = ('math.' | 'm.');
 coljoin = 'col.join';
 colprefix = 'c:';
 table_prefix = 't:';
 valprefix = 'v:';
 colremove = 'col.remove';
 colfilter = 'col.filter';
 colunfilter = 'col.unfilter';
 colimport = 'col.import';
 //('removeColumn:' | 'rm:' | 'del:' | 'rem:');
 colset = 'col.set';
 //('setColumn:' | 'sc:' | 'set:');
 colpivot = 'col.pivot';
 colfocus = 'col.focus';
 colalias = 'col.alias';
 //('pivotColumn:' | 'pivot:' | 'pc:');
 collink = 'link:';
 show_hide = ('on' | 'off');
 mod = '%';
 l_par = '(';
 r_par = ')';
 l_bracket = '[';
 r_bracket = ']';
 l_curl_bracket = '{';
 r_curl_bracket = '}';
 group = 'group:';
 blank = (' ' | 13 | 10)+;
 space = (' ' | 13)+;
 equal = '=';
 newline = '\r'? '\n';
 java = 'j:';
 python = 'p:';
 proc = 'm:';
 this = 'this';
 null = 'null';
 import_type = ('flat' | 'tree');
 rel_type = ('inner.join' | 'outer.join' | 'right.outer.join' | 'left.outer.join' | 'cross.join' | 'self.join' ); 
 dataimporttoken = 'data.import';
 dataremovetoken = 'data.remove';
 literal = (letter_s | letter_b | digit | underscore)*;// | special)*;
 help_token = 'info.help';
 codeblock = code alphanumeric* code;
 word = quote not_quote+ quote;
 panelviz =  panelprefix '.viz';
 panelclone = panelprefix '.clone';
 panelclose = panelprefix '.close';
 dataframe = 'data.frame';
 file_text = '<startInput>' alphanumeric* '<endInput>';
 panelcommentremove = panelcommentprefix '.remove';
 panelcommentedit = panelcommentprefix '.edit';
 panelcommentadd = panelcommentprefix '.add';
 panellookandfeel = panelprefix '.lookandfeel';
 paneltools = panelprefix '.tools';
 panelconfig = panelprefix '.config';
 output_token = panelprefix '.create';

Ignored Tokens
 blank;

Productions
configuration = script*;

script = {colop} colop  semicolon // column operations
		 | {varop} varop semicolon// row operations or setting up data
		 //| {j_op} j_op semicolon// java operation
		 | {expr} expr semicolon
		 //| statop
		 | {help} help semicolon
		 | {panelop} panelop semicolon
		 | newline
		 ;

colop = // colOp is usually of the form of joinColumn / addColumn / removeColumn / setColumn
		{add_column} add_column 
		| {remcol} rem_column 
		| {setcol} set_column
		| {pivotcol} pivot_column
		| {filtercol} filter_column
		| {focuscol} focus_column
		| {unfocus} unfocus
		| {import} import_column
		| {alias} alias_column
		| {import_data} import_data
		| {unfiltercol} unfilter_column
		| {remove_data} remove_data
		| {data_frame} data_frame
		;

panelop = // panelop is usually of the form of viz.change, viz.tools, viz.color
		{panel_viz} panel_viz 
		| {panel_comment} panel_comment
		| {panel_comment_remove} panel_comment_remove
		| {panel_comment_edit} panel_comment_edit
		| {panel_look_and_feel} panel_look_and_feel
		| {panel_tools} panel_tools
		| {panel_config} panel_config
		| {panel_clone} panel_clone
		| {panel_close} panel_close
		| {output_insight} output_insight
		;
 

panel_viz = // e.g. panel.viz(bar, [c:Title, c:Budget]); panelviz( vizType, ordered headers );
		panelviz l_par [layout]:id [c1]:comma [datatablealign]:flex_selector_row [c2]:comma? [uioptions]:map_obj? r_par
		;
		
panel_comment = // e.g. panel.comment.add("this looks super important", group0, coordinate, (50, 16));
		panelcommentadd l_par [text]:word [c1]:comma [type]:id [c2]:comma [location]:map_obj [c3]:comma [group]:id r_par
		;
		
panel_comment_edit = // e.g. panel.comment.edit("this looks super important", group0, coordinate, (50, 16));
		panelcommentedit l_par [text]:word [c1]:comma [type]:id [c2]:comma [location]:map_obj [c3]:comma [group]:id r_par
		;
		
panel_comment_remove = // e.g. panel.comment[0].remove();
		panelcommentremove l_par r_par
		;
		
panel_look_and_feel = // e.g. panel.lookandfeel({'color':'red'});
		panellookandfeel l_par [map]:map_obj r_par
		;
		
panel_tools = // e.g. panel.tools({'flippedaxis':'true'});
		paneltools l_par [map]:map_obj r_par
		;
		
panel_config = // e.g. panel.config({'positon':'leftside'});
		panelconfig l_par [map]:map_obj r_par
		;
		
panel_clone = // e.g. panel.clone(1);
		panelclone l_par [newid]:number r_par
		;
		
panel_close = // e.g. panel.close();
		panelclose l_par r_par
		;
		
data_frame = // e.g. panel.setBuilder('graph');
		dataframe l_par [builder]:word_or_num r_par
		;
		
add_column = // follows the pattern of addColumn(columnName and optionally the expression) addColumn(c:NewCol, 'expression', [c:col1, c:col2]);
		coladd l_par [newcol]:col_def comma [expr]:expr r_par 
		;

rem_column = // follows the pattern of addColumn(columnName and optionally the expression) removeColumn(c:colToRemove);
		colremove l_par [newcol]:col_def col_group* r_par 
		;

set_column = // follows the pattern of addColumn(columnName and optionally the expression) addColumn(c:NewCol, 'expression');
		colset l_par [newcol]:col_def comma [expr]:expr r_par 
		;

pivot_column = // grouping based on multiple columns
		colpivot l_par [firstcol]:col_def col_group+ r_par;

filter_column = // filter column using an expression
		colfilter l_par [where]:where_clause r_par;

unfilter_column = //unfilter column using col_def
		colunfilter l_par col_def r_par;
		
focus_column = // takes all the other columns and focuses on only these columns
		colfocus l_par col_def col_group* show_hide r_par
		;
		
unfocus = // you will specify it as col.focus('off');
		colfocus l_par show_hide r_par
		;

import_column = // importing data - col.import(tree | flat, [c:col1, c:col2, c:col3], [ [1,2,3] [a,b,c] ] - this is a flat
		colimport [lp1]:l_par [cols]:col_csv [relations]:relation_clause? [rp2]:r_par dot [data]:csv_table 
		;

alias_column = // sets the column aliases
		colalias [lp1]:l_par [cols]:col_csv [where]:where_statement [rp2]:r_par;

import_data = // imports from api query commands and other scripts
		dataimporttoken [lp1]:l_par [import]:import_block [joins]:relation_clause? [rp2]:r_par;
		
import_block = {api} api_block | {csv_table} csv_table | {pasted_data} pasted_data_block; 

pasted_data_block = l_par pasted_data comma [delimitier]:word_or_num r_par;

pasted_data = file_text; 

remove_data = // imports from api query commands and other scripts and deletes that data from the table
		dataremovetoken l_par api_block relation_clause? r_par; 

decimal = [whole]:number dot? [fraction]:number?;
		
expr_group = [comma]:comma [expr]:expr;		

output_insight = output_token l_par [engine_name]:id comma [insight_id]:id r_par;

api_block = api [engine_name]:id dot [insight]:id l_par [selectors]:col_csv [where]:where_statement? [relations]:relation_clause? comma? [properties]:map_obj? r_par; // the insight can also be the method
// query format
// api:Tap_Core.Query:([Selectors], [Filters], [relations])
// relations
// selector sibling selector comes from the same table
// selector comparator selector

selector = l_bracket col_csv r_bracket;

// where column clause
col_where = col_def comparator col_def_or_csv_row;

col_def_or_csv_row = {col_def} col_def | {csv} csv_row;

col_where_group = comma col_where;

//where_clause = comma? l_par col_where col_where_group* r_par; // , (
where_clause = col_where col_where_group*;

where_statement = comma? l_par where_clause r_par;
// relations
relation_def = l_bracket [from]:col_def [com1]:comma rel_type [com2]:comma [to]:col_def r_bracket;

relation_group = comma relation_def;

relation_clause = comma l_par relation_def relation_group* r_par;

if_block = l_par comparator comma term r_par;

col_group = comma col_def;

keyvalue = [word1]:word_or_num colon [word2]:word_or_num_or_nested_obj;

keyvalue_group = comma keyvalue;

map_obj = l_curl_bracket keyvalue keyvalue_group* r_curl_bracket;

group_by = l_par col_def col_group* r_par; // this is to be included in various math calculations (Studio, Genre) - this is equivalent of saving pivot on this

col_def = colprefix [colname]:id;

table_def = table_prefix [cardinality]:number; // if you want to add runtime formulas as you take the table in - instead of waiting

var_def = valprefix [valname]:id;

varop = // variable operation usually takes the form of a given variable taking ID = some stuff
		 [name]:var_def equal [expr]:expr 
		;
		
//num_csv = l_bracket decimal num_csv_group+ r_bracket; 		

csv_row = l_bracket word_or_num csv_group* r_bracket; 		// [1,3]

easy_row = word_or_num easy_group+ newline;

easy_group = comma word_or_num;

csv_table = l_bracket csv_row+ r_bracket; //[[1,3][2,4][5,6]]

col_csv = l_bracket col_def col_group* r_bracket; // this is typically of the form [c:col1, c:col2, c:col3]

word_or_num = {num} decimal | {alpha} word |{expr} [formula]:formula ; // I need some way putting an expression here

word_or_num_or_nested_obj = {word_or_num} word_or_num | {nested_map} map_obj | {nested_csv} csv_row;

flex_selector_row = l_bracket term? term_group* r_bracket;

term_group = comma term?;

formula = l_par expr r_par;
		
csv_group = comma [csv]:word_or_num; // , 3

expr_row = l_bracket [expr]:expr expr_group* r_bracket;

j_op = // this of the pattern j:{hola, hello etc.. }
	java codeblock;
	
help = help_token;
		
 expr =
  {term} term
  | {plus} [left]:term plus [right]:term
  | {minus} [left]:term minus [right]:term
  | {mult} [left]:term mult [right]:term |
  | {div} [left]:term div [right]:term 
  | {mod} [left]:term mod [right]:term
  | {e_expr} extended_expr
  //|{math_fun} math_fun // I need to still resolve other mathematical functions
  ;
 
 math_fun = proc id l_par [expr]:expr_row comma? [group]:col_csv? r_par; // m.Sum([1 + c:Activity], /*groupBy*/(c:studio, c:genre));
 
 extended_expr = l_par [expr]:expr comma? [group]:col_csv r_par; // I have no idea why I need this.. but !!
 
 term =
  {number} decimal |
  {expr} l_par expr r_par 
  | {var} valprefix [var]:id
  | {col} [col]:col_def
  | {api} api_block
  | {tab} [tab]:table_def
  | {wcsv} csv_row
  | null
  |  {alpha} word
  | {math_fun} math_fun
  | {codeblock} codeblock
  ;