Package prerna.sablecc2;

Helpers
 alpha = [['a' .. 'z'] + ['A' .. 'Z']];
 letter_s = ['a' .. 'z'];
 letter_b = ['A' .. 'Z'];
 digit = ['0' .. '9'];
 underscore = '_';
 alphanumeric = [0 .. 0xFFFF];
 quote = ('"' | ''');
 not_quote = [alphanumeric - ['"' + ''']];
 startjson = '<json>';
 endjson = '</json>';
 
Tokens
 number = ['0' .. '9']+;
 boolean = ('TRUE' | 'FALSE' | 'true' | 'false');
 sort = ('up' | 'down' | 'asc' | 'dsc');
 id = (letter_s | letter_b | digit | underscore)*;
 dot = '.';
 code_alpha='<c>' alphanumeric* '</c>';
 semicolon = ';';
 colon = ':';
 plus = '+';
 minus = '-';
 mod = '%';
 quote = ('"' | ''' | '~');
 word = quote not_quote+ quote;
 mult = '*';
 comma = ',';
 div = '/';
 comparator = ('>' | '<' | '<=' | '>=' | '!=' | '?like' | '==');
 equal = '=';
 selectorid = ('s='| 's');
 optionid = 'o=';
 projectid = 'p=';
 propid = 'props=';
 labelid = 'l=';
 joinid = 'j=';
 tooltipid = 't=';
 frameid = 'f';
 l_par = '(';
 r_par = ')';
 l_brac = '[';
 r_brac = ']';
 frameprefix = 'f$';
 blank = (' ' | 13 | 10);
 output = 'output';
 java = '<j>' alphanumeric* '</j>';
 r = '<j> runR(' alphanumeric* ')</j>';
 if = 'if';
 as_op = ('.as' | '.out');
 custom = '|';
 rel_type = ('inner.join' | 'outer.join' | 'right.outer.join' | 'left.outer.join' | 'cross.join' | 'self.join' ); 

Ignored Tokens
blank;

 
Productions 

 ///////////////////////////////////////////////////////////////////////
 ///////////////////////// START HIGHEST LEVEL /////////////////////////
 ///////////////////////////////////////////////////////////////////////
 // everything is a configuration
 // this should very very rarely change
 
 configuration = scriptchain*;
 
 scriptchain = 
	{output} routine semicolon 
	| {assign} assignment semicolon;
 
 routine = script otherscript*;
 routine_or_var = {script} routine | {constant} number_or_string | {base_formula} formula;
 
 assignment = word_or_id equal routine_or_var;
 
 // scripts are frame operations, opererations, assignments, java operations, or r operations
 // the first 3 are routines that are handled via our translation
 // while the last 2 are scripts are offloaded to other languages
 script = {frameop} frameop | {op} operation_formula | {embedded_assignment} embedded_assignment | {java_op} java_op | {r_op} r_op ;
 
 otherscript = custom script;
 ///////////////////////////////////////////////////////////////////////
 ///////////////////////// END HIGHEST LEVEL ///////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 // if we have an assignment that is embedded
 embedded_assignment = l_par id equal routine_or_var r_par;
 
 // [col, col, col... ]
 gen_row = l_brac  col_def othercol* r_brac; // generic row
 plain_row = col_def othercol*;
 
 // example - output of any operation
 operation_formula = id l_par plain_row? r_par asop?; // this is the formula with an operation in it. Although one could argue this could be a frameop - this can also be the output
 
 // Basic definitions for columns
 // columns can be a reference column / basic literal or just an expression
 // I have a feeling frame_op should not be part of col def
 // mostly because it is difficult to implement *GRIN*
 col_def = {ref} rcol | {expr} expr | {dotcol} dotcol | {frameop} frameop  | {filter} filter | {prop} prop | {relation} relationship; // need to include something for expression
 
  // creating another column
 othercol =  comma  col_def;
 
 // reference - this means the 4th column in the current frame
 rcol = frameprefix number; // f$4
 dotcol = frameid dot [column_name]:id;
 decimal = [whole]:number dot? [fraction]:number?;
 
 // word or an id
 word_or_id = {word} word | {id} id;
 // word or id or number
 number_or_string = {num} decimal | {word_or_id} word_or_id;
 
 prop = id equal number_or_string;
 
 term =
    {number_or_string} number_or_string
	| {formula} formula
	| {opformula} operation_formula
	| {boolean} boolean
	| {csv} gen_row
  //| null <- todo, will need to redefine this
  ;
  
 expr =
  {term} term
  | {plus} [left]:term plus [right]:expr
  | {minus} [left]:term minus [right]:expr
  | {mult} [left]:term mult [right]:expr 
  | {div} [left]:term div [right]:expr 
  | {mod} [left]:term mod [right]:expr
  | {e_expr} extended_expr
  ;
 
 // formula is typically being used when there are other things within it example
 // (2 *3) - 13
 formula = l_par expr r_par;
 
 // I have no idea why I need this.. but !!
 // not removing cause seems like PK has an idea about this... 
 extended_expr = l_par [expr]:expr comma? [group]:gen_row r_par; 

 // s=[col, col, col...]
 selectors = selectorid  gen_row;
 projectors = projectid  gen_row;
 labels = labelid  gen_row;
 props = propid gen_row;
 tooltips = tooltipid  gen_row;
 joins = joinid  gen_row;
 generic = id equal gen_row;
 
 noun = {select} selectors | {project} projectors | {labels} labels | {tooltips} tooltips | {others} generic | {props} props | {code} code_alpha;
 othernoun =  comma noun;

 // operations on a frame with explicit parameters
 frameop = id l_par noun othernoun* r_par asop?; // any operation on the frame. we will pick up the name through reflection
 
 // operation used for aliasing columns
 asop = as_op l_par gen_row r_par;
 
 // filter - used within if statements and filtering data from queries on a frame or datasource
 filter = l_par [lcol]:col_def  comparator [rcol]:col_def r_par; // need to ask if we should make this multiple or not
 
 // relationship is used for joins within a database and table joining when adding new data to existing frame
 relationship = l_par [lcol]:col_def rel_type [rcol]:col_def r_par;
 
 // future for java and r operations
 java_op = java;
 r_op = r;
 