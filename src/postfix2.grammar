Package prerna.sablecc2;

Helpers
 all = [0 .. 0xFFFF];
 letter_s = ['a' .. 'z'];
 letter_b = ['A' .. 'Z'];
 digit = ['0' .. '9'];
 underscore = '_';
 // words in double quotes
 // allow for escaped double quotes
 double_quote = '"';
 escaped_double_quote = '\"';
 not_double_quote = [all - '"'] | escaped_double_quote;
 double_quote_word = double_quote not_double_quote* double_quote;
 // words in single quotes
 // does not allow for escaped single quotes
 single_quote = ''';
 not_single_quote = [all - '''];
 single_quote_word = single_quote not_single_quote* single_quote;
 url_unescaped_chars = ('-' | '_' | '.' | '!' | '~' | '*' | '+' | ''' | '(' | ')' | '%');
 encoded_values = (letter_s | letter_b | digit | url_unescaped_chars);

Tokens
 meta = 'META';
 number = ['0' .. '9']+;
 boolean = ('TRUE' | 'FALSE' | 'true' | 'false');
 id = (letter_s | letter_b | digit | underscore)*;
 dot = '.';
 semicolon = ';';
 colon = ':';
 plus = '+';
 minus = '-';
 mod = '%';
 pow = '^';
 word = (single_quote_word | double_quote_word);
 mult = '*';
 comma = ',';
 div = '/';
 comparator = ('>' | '<' | '<=' | '>=' | '!=' | '?like' | '==' | '<>');
 equal = '=';
 selectorid = ('s='| 's');
 optionid = 'o=';
 projectid = 'p=';
 propid = 'props=';
 labelid = 'l=';
 joinid = 'j=';
 tooltipid = 't=';
 l_par = '(';
 r_par = ')';
 l_brac = '[';
 r_brac = ']';
 l_curl = '{';
 r_curl = '}';
 frameprefix = 'f$';
 frameid = 'f.';
 blank = (' ' | 13 | 10);
 code_alpha='<c>' encoded_values* '</c>';
 java = '<j>' encoded_values* '</j>';
 r = '<j> runR(' encoded_values* ')</j>';
 if = 'if';
 as_op = ('.as' | '.out');
 custom = '|';
 rel_type = ('inner.join' | 'outer.join' | 'right.outer.join' | 'left.outer.join' | 'cross.join' | 'self.join' ); 
 
Ignored Tokens
blank;

Productions 

 ///////////////////////////////////////////////////////////////////////
 ///////////////////////// START HIGHEST LEVEL /////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 configuration = routine* ;
 
 // all routines are a series of scripts
 // or an assignment from the series of scripts
 routine = 
	{output} script semicolon 
	| {assign} assignment semicolon
	;
 
 // i need a way to allow for an embedded_script
 // but i need it to not conflict with a formula
 // so this is basically just enforcing that there is a pipe
 mandatory_scriptchain = expr otherscript+;
 
 script = scriptstart otherscript*;
 scriptstart = {expression} expr | {meta} meta;
 otherscript = custom expr;

 // an assignment if a word or number equal to
 // some kind of evaluation
 assignment = word_or_id equal script;
 
 ///////////////////////////////////////////////////////////////////////
 ///////////////////// JSON Pieces ////////////////////////////////////
 //////////////////////////////////////////////////////////////////////
 
 //jsonnode = l_curl jsonkeyvalue anotherjsonkeyvalue* r_curl;
 
 
 ///////////////////////////////////////////////////////////////////////
 ///////////////////////// END HIGHEST LEVEL ///////////////////////////
 ///////////////////////////////////////////////////////////////////////
  
 ///////////////////////////////////////////////////////////////////////
 //////////////////////////// COMPOSITES  //////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 // this is the highest level object that the user interacts with
 // this is a base expression -> which goes all the way down to a basic number/string
 // and it includes comparisons
 expr =
  {base_expr} base_expr
  | {comparison} [left]:base_expr comparator [right]:base_expr
  // note that the embedded_assignment can be set to an inner script!
  // or we can have a full inner script just for fun as well!
  | {embedded_scriptchain} l_par mandatory_scriptchain r_par 
  | {embedded_assignment} l_par id equal script r_par
  ;
 
 // expr component goes from a defined reactor all the way down to basic number/string
 // everything else is just some mathematical operation using expr_component
 base_expr =  
	{expr_component} expr_component
	| {plus} [left]:expr_component plus [right]:base_expr
	| {minus} [left]:expr_component minus [right]:base_expr
	| {mult} [left]:expr_component mult [right]:base_expr 
	| {div} [left]:expr_component div [right]:base_expr 
	| {mod} [left]:expr_component mod [right]:base_expr
	;
 
 // base expression component is a term or a power
 expr_component = {term} term | {power} power;
 
 // to handle 5 ^ 2
 power = [base]:term pow [exponent]:term;
 
 term = {reg_term} reg_term | {neg_term} neg_term | {pos_term} pos_term;
 // to accomodate for -var and +var 
 neg_term = minus term;
 pos_term = plus term;
 
 reg_term =
    {scalar} scalar
	| {map} map
	| {formula} formula
	| {operation} operation
	| {ref} rcol
	| {dotcol} dotcol 
	| {java_op} java_op 
	| {r_op} r_op
	| {list} list
	| {csv} gen_row
  //| null <- todo, will need to redefine this
  	; 
 
 // need to able to group expressions 
 // will call this a formula
 // required for correct order of operations
 formula = l_par expr r_par;
 
 // need to allow a list of expressions
 list = l_par expr other_expr+ r_par;
 other_expr = comma expr;
 
 // operation is how is how we define PKSL functions (reactors)
 // previously had frameop and operation_formula
 // now they are combined so you can have ID(a, b, x=[c]) all in one
 operation = id l_par op_input? other_op_input* r_par asop?;
 op_input = {noun} noun | {input} col_def;
 other_op_input = comma op_input;

 // when we need an array of arrays
 gen_row = l_brac col_def? othercol* r_brac; 
 othercol =  comma col_def;
 
 // col def is an expression, a prop, or a relationship
 col_def = {expr} expr 
		| {prop} prop 
		| {relation} relationship
		;
  
 // NOUN ::: id = [gen_row, gen_row, gen_row...]
 // generic is the catch all
 // then we have defined a few specific ones
 // code alpha is the only noun which differs
 noun = {select} selectors | {project} projectors | {labels} labels | {tooltips} tooltips | {others} generic | {props} props | {code} code_alpha;
 
 generic = id equal gen_row;
 selectors = selectorid  gen_row;
 projectors = projectid  gen_row;
 labels = labelid  gen_row;
 props = propid gen_row;
 tooltips = tooltipid gen_row;
 joins = joinid  gen_row;

 // TODO: determine if we still need this
 prop = id equal scalar;
 
 // operation used for aliasing columns
 asop = as_op l_par gen_row r_par;
 
 // relationship is used for joins within a database and table joining when adding new data to existing frame
 relationship = {explicit} explicit_rel | {implicit} implicit_rel;
 implicit_rel = l_par [lcol]:col_def [comma1]:comma rel_type [comma2]:comma [rcol]:col_def r_par; 
 explicit_rel = l_par [lcol]:col_def [comma1]:comma rel_type [comma2]:comma [rcol]:col_def [comma3]:comma [relationship_name]:col_def r_par;
 
 ///////////////////////////////////////////////////////////////////////
 /////////////////////// JSON composites //////////////////////////////
 //////////////////////////////////////////////////////////////////////
 
 
/*jsonarrayvalue = l_brac scalar* r_brac;
jsonvalueoptions = {array} jsonarrayvalue | {scalar} scalar | {node} jsonnode;
jsonkeyvalue = id colon jsonvalueoptions;
anotherjsonkeyvalue = comma jsonkeyvalue;
*/
 
 
 ///////////////////////////////////////////////////////////////////////
 ////////////////////////// END COMPOSITES  ////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 
 
 ///////////////////////////////////////////////////////////////////////
 ////////////////////////////// OTHER  /////////////////////////////////
 ///////////////////////////////////////////////////////////////////////
  
 // for java and r operations
 java_op = java;
 r_op = r;

 // reference - this means the 4th column in the current frame
 rcol = frameprefix number; // f$4
 dotcol = frameid [column_name]:id; // f.Title
 
 ///////////////////////////////////////////////////////////////////////
 //////////////////////////// END OTHER  ///////////////////////////////
 ///////////////////////////////////////////////////////////////////////

 ///////////////////////////////////////////////////////////////////////
 ////////////////////////////// MAP ////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 // map is a key : value
 // where the value is a scalar, varaible, vector of scalars/variables, or another nested map
 map = l_curl map_entry? other_map_entry* r_curl;
 
 map_entry = [key]:word colon [val]:values;
 other_map_entry = [comma]:comma map_entry;
 
 // DO NOT USE THE BELOW FOR ANYTHING ASIDE FOR MAPS!
 // we already have a way to take vectors
 // this is just because we only want to maintain scalars and not allow for
 // evaluations in maps that are being stored on the BE
 values = {simple} map_base_input | {list} map_list | {nested_map} map;
 
 map_list = l_brac map_extended_input? map_list_extend* r_brac;
 map_list_extend = comma map_extended_input;
 
 map_extended_input = {list} map_list | {scalar} map_base_input | {nested_map} map;  
 map_base_input = {map_var} map_var | {normal_scalar} scalar;
 map_var = [start]:l_curl [var]:id [end]:r_curl;
 
 ///////////////////////////////////////////////////////////////////////
 /////////////////////////// END MAP ///////////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 
 ///////////////////////////////////////////////////////////////////////
 ///////////////////////// LOWEST LEVEL ////////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 // word or id or number
 scalar = {num} decimal | {word_or_id} word_or_id | {boolean} boolean;
 
 // word or an id
 word_or_id = {word} word | {id} id;
 
 // numbers
 decimal = {whole_decimal} whole_decimal | {fraction_decimal} fraction_decimal;
 whole_decimal = [whole]:number dot? [fraction]:number?;
 fraction_decimal = dot [fraction]:number;
 
 ///////////////////////////////////////////////////////////////////////
 /////////////////////// END LOWEST LEVEL //////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 