Package prerna.sablecc2;

Helpers
 alpha = [['a' .. 'z'] + ['A' .. 'Z']];
 letter_s = ['a' .. 'z'];
 letter_b = ['A' .. 'Z'];
 digit = ['0' .. '9'];
 underscore = '_';
 alphanumeric = [0 .. 0xFFFF];
 quote = ('"' | ''');
 not_quote = [alphanumeric - ['"' + ''']];
 startjson = '<json>';
 endjson = '</json>';
 
Tokens
 number = ['0' .. '9']+;
 boolean = ('TRUE' | 'FALSE' | 'true' | 'false');
 sort = ('up' | 'down' | 'asc' | 'dsc');
 id = (letter_s | letter_b | digit | underscore)*;
 dot = '.';
 code_alpha='<c>' alphanumeric* '</c>';
 semicolon = ';';
 colon = ':';
 plus = '+';
 minus = '-';
 mod = '%';
 pow = '^';
 quote = ('"' | ''' | '~');
 word = quote not_quote+ quote;
 mult = '*';
 comma = ',';
 div = '/';
 comparator = ('>' | '<' | '<=' | '>=' | '!=' | '?like' | '==');
 equal = '=';
 selectorid = ('s='| 's');
 optionid = 'o=';
 projectid = 'p=';
 propid = 'props=';
 labelid = 'l=';
 joinid = 'j=';
 tooltipid = 't=';
 frameid = 'f';
 l_par = '(';
 r_par = ')';
 l_brac = '[';
 r_brac = ']';
 frameprefix = 'f$';
 blank = (' ' | 13 | 10);
 output = 'output';
 java = '<j>' alphanumeric* '</j>';
 r = '<j> runR(' alphanumeric* ')</j>';
 if = 'if';
 as_op = ('.as' | '.out');
 custom = '|';
 rel_type = ('inner.join' | 'outer.join' | 'right.outer.join' | 'left.outer.join' | 'cross.join' | 'self.join' ); 

Ignored Tokens
blank;

 
Productions 

 ///////////////////////////////////////////////////////////////////////
 ///////////////////////// START HIGHEST LEVEL /////////////////////////
 ///////////////////////////////////////////////////////////////////////
 // everything is a configuration
 // this should very very rarely change
 
 configuration = routine*;
 
 // all routines are a series of scripts
 // or an assignment from the series of scripts
 routine = 
	{output} scriptchain semicolon 
	| {assign} assignment semicolon
	;
 
 scriptchain = script otherscript*;
 otherscript = custom script;

 // an assignment if a word or number equal to
 // some kind of evaluation
 assignment = word_or_id equal scriptchain;
 
 // script is any expression
 // or an assignment
 script = {expression} expr 
		| {embedded_assignment} embedded_assignment 
		;
 
  // if we have an assignment that is embedded within a script
 embedded_assignment = l_par id equal script r_par;
 
 ///////////////////////////////////////////////////////////////////////
 ///////////////////////// END HIGHEST LEVEL ///////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 expr =
  {term} term
  | {plus} [left]:term plus [right]:expr
  | {minus} [left]:term minus [right]:expr
  | {mult} [left]:term mult [right]:expr 
  | {div} [left]:term div [right]:expr 
  | {mod} [left]:term mod [right]:expr
  | {pow} [left]:term pow [right]:expr
  ;
  
 term =
    {scalar} scalar
	| {formula} formula
	| {opformula} operation_formula
	| {frameop} frameop
	| {java_op} java_op 
	| {r_op} r_op
	| {list} list
	| {csv} gen_row
  //| null <- todo, will need to redefine this
  	; 
 
 // need to able to group formulas together
 // will call this a formula
 // and allow for list of expressions
 formula = l_par expr r_par;
 list = l_par expr other_expr+ r_par;
 other_expr = comma expr;
 
 // col def is an expression, a reference to a frame header
 // or a filter/prop/relationship to be used within an operation
 col_def = {expr} expr 
		| {ref} rcol
		| {dotcol} dotcol 
		| {filter} filter 
		| {prop} prop 
		| {relation} relationship
		; // need to include something for expression
 
 // creating another column
 othercol =  comma col_def;
 
 // different ways to define col_def within operations
 gen_row = l_brac  col_def othercol* r_brac; // generic row
 plain_row = l_par col_def? othercol* r_par;
 
 // example - output of any operation
 operation_formula = id plain_row asop?;
 
 // reference - this means the 4th column in the current frame
 rcol = frameprefix number; // f$4
 dotcol = frameid dot [column_name]:id;
 
 pos_or_neg = {minus}minus | {plus}plus;
 decimal = [pos_or_neg]:pos_or_neg? [whole]:number dot? [fraction]:number?;
 
 // word or an id
 word_or_id = {word} word | {id} id;
 // word or id or number
 scalar = {num} decimal | {word_or_id} word_or_id | {boolean} boolean;
 
 prop = id equal scalar;

 // s=[col, col, col...]
 selectors = selectorid  gen_row;
 projectors = projectid  gen_row;
 labels = labelid  gen_row;
 props = propid gen_row;
 tooltips = tooltipid gen_row;
 joins = joinid  gen_row;
 generic = id equal gen_row;
 
 noun = {select} selectors | {project} projectors | {labels} labels | {tooltips} tooltips | {others} generic | {props} props | {code} code_alpha;
 othernoun =  comma noun;

 // operations on a frame with explicit parameters
 frameop = id l_par noun othernoun* r_par asop?; // any operation on the frame. we will pick up the name through reflection
 
 // operation used for aliasing columns
 asop = as_op l_par gen_row r_par;
 
 // filter - used within if statements and filtering data from queries on a frame or datasource
 filter = l_par [lcol]:col_def  comparator [rcol]:col_def r_par; // need to ask if we should make this multiple or not
 
 // relationship is used for joins within a database and table joining when adding new data to existing frame
 relationship = l_par [lcol]:col_def rel_type [rcol]:col_def r_par;
 
 // future for java and r operations
 java_op = java;
 r_op = r;
 