Package prerna.sablecc2;

Helpers
 alpha = [['a' .. 'z'] + ['A' .. 'Z']];
 letter_s = ['a' .. 'z'];
 letter_b = ['A' .. 'Z'];
 digit = ['0' .. '9'];
 underscore = '_';
 alphanumeric = [0 .. 0xFFFF];
 quote = ('"' | ''');
 not_quote = [alphanumeric - ['"' + ''']];
 startjson = '<json>';
 endjson = '</json>';
 
Tokens
 number = ['0' .. '9']+;
 boolean = ('TRUE' | 'FALSE' | 'true' | 'false');
 sort = ('up' | 'down' | 'asc' | 'dsc');
 id = (letter_s | letter_b | digit | underscore)*;
 dot = '.';
 code_alpha='<c>' alphanumeric* '</c>';
 semicolon = ';';
 colon = ':';
 plus = '+';
 minus = '-';
 mod = '%';
 pow = '^';
 quote = ('"' | ''' | '~');
 word = quote not_quote* quote;
 mult = '*';
 comma = ',';
 div = '/';
 comparator = ('>' | '<' | '<=' | '>=' | '!=' | '?like' | '==' | '<>');
 equal = '=';
 selectorid = ('s='| 's');
 optionid = 'o=';
 projectid = 'p=';
 propid = 'props=';
 labelid = 'l=';
 joinid = 'j=';
 tooltipid = 't=';
 l_par = '(';
 r_par = ')';
 l_brac = '[';
 r_brac = ']';
 l_curl = '{';
 r_curl = '}';
 frameprefix = 'f$';
 frameid = 'f';
 blank = (' ' | 13 | 10);
 output = 'output';
 java = '<j>' alphanumeric* '</j>';
 r = '<j> runR(' alphanumeric* ')</j>';
 if = 'if';
 as_op = ('.as' | '.out');
 custom = '|';
 rel_type = ('inner.join' | 'outer.join' | 'right.outer.join' | 'left.outer.join' | 'cross.join' | 'self.join' ); 

Ignored Tokens
blank;

Productions 

 ///////////////////////////////////////////////////////////////////////
 ///////////////////////// START HIGHEST LEVEL /////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 configuration = routine*;
 
 // all routines are a series of scripts
 // or an assignment from the series of scripts
 routine = 
	{output} scriptchain semicolon 
	| {assign} assignment semicolon
	;
 
 scriptchain = script otherscript*;
 otherscript = custom script;

 // an assignment if a word or number equal to
 // some kind of evaluation
 assignment = word_or_id equal scriptchain;
 
 // script is any expression
 // or an assignment
 script = {expression} expr 
		| {embedded_assignment} embedded_assignment 
		;
 
  // if we have an assignment that is embedded within a script
 embedded_assignment = l_par id equal script r_par;
 
 ///////////////////////////////////////////////////////////////////////
 ///////////////////////// END HIGHEST LEVEL ///////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 
 
 ///////////////////////////////////////////////////////////////////////
 //////////////////////////// COMPOSITES  //////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 // this is the highest level object that the user interacts with
 // this is a base expression -> which goes all the way down to a basic number/string
 // and it includes comparisons
 expr =
  {base_expr} base_expr
  | {comparison} [left]:base_expr comparator [right]:base_expr
  ;
 
 // expr component goes from a defined reactor all the way down to basic number/string
 // everything else is just some mathematical operation using expr_component
 base_expr =  
	{expr_component} expr_component
	| {plus} [left]:expr_component plus [right]:base_expr
	| {minus} [left]:expr_component minus [right]:base_expr
	| {mult} [left]:expr_component mult [right]:base_expr 
	| {div} [left]:expr_component div [right]:base_expr 
	| {mod} [left]:expr_component mod [right]:base_expr
	;
 
 // base expression component is a term or a power
 expr_component = {term} term | {power} power;
 
 // to handle 5 ^ 2
 power = [base]:term pow [exponent]:term;
 
 term = {reg_term} reg_term | {neg_term} neg_term | {pos_term} pos_term;
 // to accomodate for -var and +var 
 neg_term = minus term;
 pos_term = plus term;
 
 reg_term =
    {scalar} scalar
	| {map} map
	| {formula} formula
	| {opformula} operation_formula
	| {frameop} frameop
	| {ref} rcol
	| {dotcol} dotcol 
	| {java_op} java_op 
	| {r_op} r_op
	| {list} list
	| {csv} gen_row
  //| null <- todo, will need to redefine this
  	; 
 
 // need to able to group expressions 
 // will call this a formula
 // required for correct order of operations
 formula = l_par expr r_par;
 
 // need to allow a list of expressions
 list = l_par expr other_expr+ r_par;
 other_expr = comma expr;
 
 // operational formula and frameop is how we define PKSL functions (reactors)
 // both use the same reactor, but they only differ in how data is pushed into the reactor
 // OPFORMULA ::: SUM(1,2,3)
 // FRAMEOP ::: Iterate(QUERYSTRUCT=[qs]); ---> where qs is a predefined variable
 operation_formula = id plain_row asop?;
 frameop = id l_par noun othernoun* r_par asop?;

 // different ways to define col_def within operations
 // GENROW ::: [coldef1, coldef2, coldef3]
 // PLAINROW ::: (coldef1, coldef2, coldef3)
 gen_row = l_brac col_def othercol* r_brac; 
 plain_row = l_par col_def? othercol* r_par;
 
 // col def is an expression, a prop, or a relationship
 col_def = {expr} expr 
		| {prop} prop 
		| {relation} relationship
		;
 
 // to have multiple cols within the gen_row and plain_row
 othercol =  comma col_def;
 
 // NOUN ::: id = [coldef1, coldef2, coldef3...]
 // generic is the catch all
 // then we have defined a few specific ones
 // code alpha is the only noun which differs
 noun = {select} selectors | {project} projectors | {labels} labels | {tooltips} tooltips | {others} generic | {props} props | {code} code_alpha;
 othernoun =  comma noun;
 
 generic = id equal gen_row;
 selectors = selectorid  gen_row;
 projectors = projectid  gen_row;
 labels = labelid  gen_row;
 props = propid gen_row;
 tooltips = tooltipid gen_row;
 joins = joinid  gen_row;

 // TODO: determine if we still need this
 prop = id equal scalar;
 
 // operation used for aliasing columns
 asop = as_op l_par gen_row r_par;
 
 // relationship is used for joins within a database and table joining when adding new data to existing frame
 relationship = {explicit} explicit_rel | {implicit} implicit_rel;
 implicit_rel = l_par [lcol]:col_def [comma1]:comma rel_type [comma2]:comma [rcol]:col_def r_par; 
 explicit_rel = l_par [lcol]:col_def [comma1]:comma rel_type [comma2]:comma [rcol]:col_def [comma3]:comma [relationship_name]:col_def r_par;
 
 ///////////////////////////////////////////////////////////////////////
 ////////////////////////// END COMPOSITES  ////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 
 
 ///////////////////////////////////////////////////////////////////////
 ////////////////////////////// OTHER  /////////////////////////////////
 ///////////////////////////////////////////////////////////////////////
  
 // for java and r operations
 java_op = java;
 r_op = r;

 // reference - this means the 4th column in the current frame
 rcol = frameprefix number; // f$4
 dotcol = frameid dot [column_name]:id; // f.Title
 
 ///////////////////////////////////////////////////////////////////////
 //////////////////////////// END OTHER  ///////////////////////////////
 ///////////////////////////////////////////////////////////////////////

 ///////////////////////////////////////////////////////////////////////
 ////////////////////////////// MAP ////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 // map is a key : value
 // where the value is a scalar, vector of scalars, or another nested map
 map = l_curl map_entry other_map_entry* r_curl;
 
 map_entry = [key]:scalar colon [val]:values;
 other_map_entry = [comma]:comma map_entry;
 
 // DO NOT USE THE BELOW FOR ANYTHING ASIDE FOR MAPS!
 // we already have a way to take vectors
 // this is just because we only want to maintain scalars and not allow for
 // evaluations in maps that are being stored on the BE

 values = {simple_scalar} scalar | {vector} map_scalar_list | {nested_map} map;
 
 // allow for an empty list
 // by making the first scalar optional and the other_scalar can be 0
 map_scalar_list = l_brac scalar? other_scalar* r_brac;
 other_scalar = comma scalar;
 
 ///////////////////////////////////////////////////////////////////////
 /////////////////////////// END MAP ///////////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 
 ///////////////////////////////////////////////////////////////////////
 ///////////////////////// LOWEST LEVEL ////////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 
 // word or id or number
 scalar = {num} decimal | {word_or_id} word_or_id | {boolean} boolean;
 
 // word or an id
 word_or_id = {word} word | {id} id;
 
 // numbers
 decimal = {whole_decimal} whole_decimal | {fraction_decimal} fraction_decimal;
 whole_decimal = [whole]:number dot? [fraction]:number?;
 fraction_decimal = dot [fraction]:number;
 
 ///////////////////////////////////////////////////////////////////////
 /////////////////////// END LOWEST LEVEL //////////////////////////////
 ///////////////////////////////////////////////////////////////////////
 